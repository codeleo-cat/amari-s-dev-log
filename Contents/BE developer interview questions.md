• Base64 인코딩이란?
-> binary data를 ASCII 문자 집합으로 변환하는 방법으로, 64개의 문자와 패딩 문자를 사용해 데이터를 인코딩합니다.
- 텍스트만 허용되는 환경에서 binary 데이터를 안전하게 전송하기 위함.
- 데이터 크기가 약 33% 증가.

• 사용자 패스워드를 전송/보관하는 방법은?  
-> 전송 시 : HTTPS와 같은 SSL/TLS 암호화된 채널을 통해 전송해야 합니다.
-> 보관 시 : password를 일반 텍스트가 아니라 해싱 알고리즘을 사용해 DB에 저장해야 합니다. bcrypt 같은 해시 함수를 사용했었고, #salt 를 추가하여 브루트포스 공격이나 레인보우 테이블 공격을 막습니다.
- salt : 패스워드 해시 함수에 무작위 데이터를 추가하여 동일한 패스워드라도 다른 해시값을 생성하게 함.

• system call이란?
-> User mode에서 실행 중인 애플리케이션이 OS 체제의 Kernel 모드에서 제공하는 서비스나 자원을 요청하는 매커니즘입니다. 주로 파일 시스템, 네트워크, 프로세스 제어와 같은 자원에 접근할 때 사용됩니다. (일종의 추상화 layer)
ex) 파일 open, write, read
- User mode - (context-switching) -> Kernel Mode

• .so와 .a 파일의 차이는?  
.so (Shared Object) - 동적 라이브러리 파일로 프로그램이 실행될 때 런타임에 동적으로 링크됩니다. 따라서 메모리 사용량을 절약할 수 있습니다.
.a (Archive) - 정적 라이브러리 파일로 컴파일 시에 프로그램에 링크됩니다. 이 경우, library의 코드가 프로그램에 포함되어 배포되므로 파일 크기가 커질 수 있습니다.
-> 동적 라이브러리는 업데이트할 때 모든 관련 프로그램이 자동으로 최신 버전을 사용하지만 정적 라이브러리의 경우 re-compile 과정이 필요합니다. 결론적으로, **정적 라이브러리는 배포와 의존성 관리가 편하지만 메모리 효율은 떨어집니다.**


• MySQL과 MongoDB의 차이점은? 
-> MySQL은 RDBMS로 데이터를 구조화하여 테이블에 저장하고, 데이터 간의 관계를 정의하는 *스키마*가 존재합니다.
이에 반해 MongoDB는 NoSQL DB로 데이터를 document 형식으로 저장합니다. 스키마가 없거나 유연한 구조를 가질 수 있습니다. Scale-out에 용이하고, #sharding 을 통해 여러 서버에 데이터를 분산하여 처리할 수 있습니다. 결론적으로 MySQL은 복잡한 관계형 데이터를 처리하는 데 적합하고(일관성을 중시), MongoDB는 빠른 개발 및 대규모 데이터를 처리하는 애플리케이션에 유리합니다. (가용성과 확장성을 더 우선시)


• HTTP/2의 특징은?
HTTP/2는 **HTTP/1.1의 성능 문제를 개선**한 새로운 프로토콜로, 웹의 빠르고 효율적인 통신을 위해 설계되었습니다. 주요 특징은 다음과 같습니다:

• **멀티플렉싱(Multiplexing)**: 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있습니다. 이는 HTTP/1.1의 문제였던 “헤드-오브-라인 블로킹”을 해결하여 더 빠르게 페이지를 로드할 수 있습니다.
• **헤더 압축**: HTTP/2는 요청과 응답에서 반복되는 헤더 정보를 **HPACK**이라는 기술로 압축하여, 네트워크 대역폭을 절약하고 성능을 향상시킵니다.
• **서버 푸시(Server Push)**: 서버가 클라이언트의 요청 없이도 미리 자원을 전송할 수 있는 기능입니다. 예를 들어, HTML 파일을 요청하면 CSS, JS 파일을 클라이언트에게 미리 보낼 수 있습니다.
• **이진 프레이밍(Binary Framing)**: 텍스트 기반이었던 HTTP/1.x와 달리, HTTP/2는 데이터를 이진 형식으로 처리하여 더 빠르고 효율적인 전송을 가능하게 합니다.

• Firewall의 동작 원리는?
Firewall(방화벽)은 네트워크 보안을 유지하기 위해 **트래픽을 필터링**하는 장치나 소프트웨어입니다. 외부로부터의 공격을 방지하고 내부 네트워크를 보호하기 위해 사용됩니다.

• **패킷 필터링**: 방화벽은 들어오고 나가는 네트워크 패킷을 **IP 주소**, **포트 번호**, **프로토콜** 등의 기준에 따라 필터링하여 허용 또는 차단합니다.
• **상태 기반 필터링 (Stateful Inspection)**: 방화벽은 트래픽의 상태(연결이 확립되었는지 여부)를 추적하여, 기존의 연결에 대한 응답을 허용하고 새로운 비인가된 연결을 차단합니다.
• **애플리케이션 레벨 필터링**: 고급 방화벽은 특정 애플리케이션의 트래픽을 분석하여 허용 여부를 결정합니다. 예를 들어, 특정 웹사이트나 특정 프로토콜을 차단할 수 있습니다.
• **네트워크 주소 변환(NAT)**: 방화벽은 NAT를 통해 내부 네트워크의 IP 주소를 숨기고 외부에서는 공용 IP 주소만 볼 수 있게 하여 보안을 강화합니다.

• Docker와 Virtual Machine의 차이점은?
Docker와 가상 머신(VM)은 모두 격리된 환경에서 애플리케이션을 실행하기 위한 기술이지만, 그 방식이 다릅니다.
• **가상 머신 (Virtual Machine)**:
• **하이퍼바이저**를 통해 호스트 OS 위에 별도의 **게스트 OS**를 실행합니다. 각 VM은 자체 운영체제를 포함하고 있어 무겁고 리소스 사용량이 큽니다.
• 예를 들어, 각각의 VM은 CPU, 메모리, 디스크 등의 리소스를 자체적으로 할당받으며, 호스트 OS 위에서 완전한 가상 환경을 제공받습니다.

• **Docker (컨테이너)**:
• Docker는 **컨테이너** 기반 가상화 기술로, OS의 **커널**을 공유하면서 애플리케이션을 독립된 환경에서 실행합니다. 즉, OS 레벨에서 격리된 프로세스들만 존재하므로, 가상 머신보다 **더 가볍고 빠릅니다**.
• 각 컨테이너는 파일 시스템, CPU, 메모리, 네트워크 등 리소스가 격리되지만, **호스트 OS의 커널을 공유**하기 때문에 VM처럼 완전한 가상 환경은 아닙니다.

• AMD와 Intel CPU의 차이점은? 
• **Intel**은 일반적으로 **단일 코어 성능**이 우수하며, 클럭 속도가 빠른 경향이 있습니다. 이는 게임과 같은 **싱글 스레드 작업**에 적합합니다.
• **AMD**는 **멀티코어 성능**에서 우위를 점하며, **다중 스레드 작업**에 유리합니다. 따라서 고성능 컴퓨팅이나 멀티태스킹 작업에서 AMD의 성능이 더 우수할 수 있습니다.

• CRDT란?
CRDT(Conflict-Free Replicated Data Type)는 **분산 시스템에서 데이터 동기화를 위한 데이터 구조**입니다. 네트워크의 분리나 지연이 발생할 때에도 각 노드에서 로컬로 데이터 조작을 할 수 있으며, 이후 병합 시에 **충돌 없이** 일관된 상태를 유지할 수 있습니다.

• **작동 원리**:
• 각 노드에서 독립적으로 데이터를 수정할 수 있고, 수정 사항이 서로 충돌하지 않도록 데이터 타입 자체가 설계됩니다.
• 데이터가 병합될 때 **수학적으로 증명된 방법**으로 일관된 상태로 합쳐지기 때문에 충돌이 발생하지 않습니다.
• **유형**:
• **G-Counter (증가형 카운터)**: 노드들이 값을 독립적으로 증가시키고, 병합 시에는 각 노드의 증가값을 모두 합산합니다.
• **PN-Counter (증가/감소 카운터)**: 증가와 감소를 모두 허용하며, 병합 시에도 일관된 값을 유지합니다.
• **Set (집합)**: 추가-삭제 동작이 가능한 집합 구조로, 병합 시에도 집합의 일관성을 보장합니다.
• **사용 사례**:
• 분산 데이터베이스, 협업 도구(문서 편집), 채팅 시스템 등에서 **네트워크의 일관성 문제**를 해결하기 위해 사용됩니다.


• CORS란?  
• CI/CD란?  
• 동시 사용자 1만명을 지원하는 채팅 서버를 어떻게 만들겠는가?  

- DB - 캐시 계층. Redis Memcached
- 

• 최근 사회적 이슈가 된 보안 관련 사고 몇가지의 원인과 대책은?  
• 대용량 로그 시스템을 구축한다면 어떻게 하겠는가?