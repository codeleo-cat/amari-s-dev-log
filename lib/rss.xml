<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 1745 at column 359: Input is not proper UTF-8, indicate encoding !
Bytes: 0x1D 0x0A 0x3C 0x62
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[obsidian-icloud]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>obsidian-icloud</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 18 Mar 2024 02:12:14 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 18 Mar 2024 02:12:02 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[15단계로 배우는 도커와 쿠버네티스]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> <a class="tag" href="?query=tag:Namespace" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Namespace</a> <a class="tag" href="?query=tag:cgroup" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cgroup</a> 
 <br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener">#docker</a> <a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a><br>
<img alt="100" src="https://image.yes24.com/goods/93317828/XL" referrerpolicy="no-referrer"><br><br>
<br>쿠버네티스란?

<br>

<br>클러스터 관리를 담당하는 마스터와 2)컨테이너화된 애플리케이션을 실제로 실행하는 노드 두 종류 서버로 구성된다.




<br>컨테이너의 이해

<br>리눅스 커널 기술 - <a href=".?query=tag:Namespace" class="tag" target="_blank" rel="noopener">#Namespace</a>, <a href=".?query=tag:cgroup" class="tag" target="_blank" rel="noopener">#cgroup</a>


<br>쿠버네티스의 기본<br>
Pod

<br>쿠버네티스에서 컨테이너를 실행하는 최소 단위이다.<br>
Service <a data-tooltip-position="top" aria-label="Service" data-href="Service" href="docker-&amp;-k8s/service.html" class="internal-link" target="_self" rel="noopener">👉</a>
<br>client의 요청을 파드에 전달하는 역할을 담당한다. (파드의 ip주소는 가동 시마다 바뀌기 때문!) 
<br>서비스는 대표 IP 주소 (Cluster IP)를 가진다.


<br>이 책의 학습 환경

<br>환경 1, 2 - 업스트림 (회사가 손대지 않은 상태)
<br>환경 3 - GKE


<br>도커 커맨드 치트 시트

<br>2017년 1월 ~ container, image와 같이 대상이 되는 object 종류 지정하고 동사에 해당하는 키워드를 배치. 


<br>kubectl 커맨드 치트 시트

<br>K8s 클러스터에 명령을 내릴 때 kubectl 사용한다.
<br>kubectl 1) 커맨드 2) 리소스 타입 이름 3) 옵션


<br><br>
<br>


<br>


<br>


<br>


<br>


<br>컨테이너를 블랙박스처럼 다룰 수 있게 해주는 인터페이스


<br><br>
<br>


<br>

매니페스트<br>
: K8s의 오브젝트를 생성하기 위한 meta 정보를 YAML이나 JSON으로 기술한 파일
kubectl apply -f 매니페스트_파일명
kubectl create -f 매니페스트_파일명
kubectl delete -f 매니페스트_파일명
Copy
파드<br>
: 쿠버네티스에서 컨테이너를 실행하는 최소 단위이다.

<br>파드끼리는 클러스터 네트워크 상의 IP 주소를 바탕으로 서로 통신 가능하다.
<br>파드의 IP주소는 K8s 클러스터 외부에서 직접 접속 X
<br>파드에 헬스체크 기능 존재. kubelet이 담당한다.
<br>node의 h/w 장애 발생 → kubelet도 정지되므로 컨트롤러를 사용해야 한다. (Deployment, Statefulset)
<br>Side Car 패턴 : 하나의 파드 안에 여러 컨테이너를 조합하는 패턴 (재사용성, 생산성 ↑)<br>
<br>


<br>

디플로이먼트<br>
: 파드의 개수를 관리하는 역할

<br>스케일 기능
<br>롤아웃 기능
<br>롤백 기능
<br>자동 복구 기능<br>
<br>


<br>

<br>

<br>

<br>

<br>

<br>

<br>

 <br>
 

<br>

<br>

<br>

: 부하에 반응하여 자동으로 처리 능력 조절

<br>HPA
<br>CA<br>
<br>


<br>

: K8s 클러스터를 논리적으로 분할하여 RBAC과 조합하여 운영 환경 구축

]]></description><link>books/15단계로-배우는-도커와-쿠버네티스.html</link><guid isPermaLink="false">Books/15단계로 배우는 도커와 쿠버네티스.md</guid><pubDate>Sun, 18 Feb 2024 06:47:23 GMT</pubDate><enclosure url="https://image.yes24.com/goods/93317828/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/93317828/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Release의 모든 것]]></title><description><![CDATA[ 
 <br><img alt="100" src="https://image.yes24.com/goods/123763401/XL" referrerpolicy="no-referrer">]]></description><link>books/release의-모든-것.html</link><guid isPermaLink="false">Books/Release의 모든 것.md</guid><pubDate>Mon, 08 Jan 2024 06:00:01 GMT</pubDate><enclosure url="https://image.yes24.com/goods/123763401/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/123763401/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그림으로 공부하는 IT인프라 구조]]></title><description><![CDATA[<a class="tag" href="?query=tag:Polling" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Polling</a> 
 <br><img alt="100" src="https://image.yes24.com/goods/95800974/XL" referrerpolicy="no-referrer"><br>
<br>
폴링 ( <a href=".?query=tag:Polling" class="tag" target="_blank" rel="noopener">#Polling</a> ) 정기적으로 질의하는 것<br>
ex) 집배원이 정기적으로 우편함을 확인하며 편지를 모은 다음 배송한다.

<br>
특징

<br>단방향 질의, 정기적으로 발생함.
<br>이와 반대되는 처리 : 이벤트 주도 / 끼어들기 방식 (On demand 방식)
<br>ex) Connection Pool : 커넥션을 미리 생성해두는 것, <br> NTP(시간 동기) 처리.


]]></description><link>books/그림으로-공부하는-it인프라-구조.html</link><guid isPermaLink="false">Books/그림으로 공부하는 IT인프라 구조.md</guid><pubDate>Tue, 16 Jan 2024 10:06:40 GMT</pubDate><enclosure url="https://image.yes24.com/goods/95800974/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/95800974/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그림으로 배우는 리눅스 구조]]></title><description><![CDATA[ 
 <br><img alt="100" src="https://image.yes24.com/goods/122109062/XL" referrerpolicy="no-referrer">]]></description><link>books/그림으로-배우는-리눅스-구조.html</link><guid isPermaLink="false">Books/그림으로 배우는 리눅스 구조.md</guid><pubDate>Mon, 08 Jan 2024 05:58:59 GMT</pubDate><enclosure url="https://image.yes24.com/goods/122109062/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/122109062/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크 교과서]]></title><description><![CDATA[ 
 <br><img alt="book" src="https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791138337526.jpg" referrerpolicy="no-referrer" style="width: 100px; max-width: 100%;"><br><br><br><br><br><br>]]></description><link>books/네트워크-교과서.html</link><guid isPermaLink="false">Books/네트워크 교과서.md</guid><pubDate>Sun, 17 Mar 2024 03:00:22 GMT</pubDate><enclosure url="https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791138337526.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791138337526.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[단위 테스트]]></title><description><![CDATA[ 
 <br><img alt="100" src="https://image.yes24.com/goods/104084175/XL" referrerpolicy="no-referrer">]]></description><link>books/단위-테스트.html</link><guid isPermaLink="false">Books/단위 테스트.md</guid><pubDate>Mon, 08 Jan 2024 06:00:25 GMT</pubDate><enclosure url="https://image.yes24.com/goods/104084175/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/104084175/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[돈의 속성]]></title><description><![CDATA[ 
 <br>좋은 돈이 찾아오게 하는 7가지 비법<br>
<br>품위 없는 모든 버릇을 버려라 - 남을 비웃는 것, 지저분한 차림, 약속에 늦는 것
<br>도움을 구하는 데 망설이지 마라.
<br>희생하라 - 돈을 모으기 위해서는 더 많이 일해야 하고, 공부를 많이 하기 위해서는 잠을 줄여야 한다.
<br>기록하라
<br>장기 목표를 가져라 - 평생 지킬 만한 가치를 찾아라.
<br>눈치 보지 말라
<br>시간이 많다고 생각하지 말라
]]></description><link>books/돈의-속성.html</link><guid isPermaLink="false">Books/돈의 속성.md</guid><pubDate>Sun, 17 Mar 2024 02:59:35 GMT</pubDate></item><item><title><![CDATA[면접을 위한 CS 전공지식 노트]]></title><description><![CDATA[<a class="tag" href="?query=tag:오버로딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#오버로딩</a> <a class="tag" href="?query=tag:오버라이딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#오버라이딩</a> <a class="tag" href="?query=tag:3-way-handshake" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#3-way-handshake</a> 
 <br><img alt="" src="https://image.yes24.com/goods/108887922/XL" referrerpolicy="no-referrer" style="width: 300px; max-width: 100%;"><br><br>가장 중요한 전산 자원은 CPU와 메모리(RAM)이다.<br>
OS는 이것들을 process에 분배한다. (컴퓨터 자원 관리)<br>스레드마다 Stack, 프로세스마다 heap과 실행 코드 영역을 갖는다.<br>가상 메모리 시스템 - RAM과 HDD를 하나의 논리적 메모리로 추상시킨 메모리 관리 기법.<br><br>1-1. 디자인 패턴<br>
<br>싱글톤

<br>ex) DB 연결 객체 생성시 오직 하나의 인스턴스만을 유지하여 중복 연결을 피한다.


<br>팩토리

<br>객체 생성 로직을 캡슐화(안 보이도록 숨긴다)하여 객체 생성을 추상화하는 패턴


<br>전략

<br>알고리즘을 정의하고 각각을 캡슐화하여 교환 가능하도록 만드는 패턴


<br>옵저버

<br>객체 사이에 1:N 의존성을 정의하여 한 객체의 상태 변경이 다른 객체들에게 통지되는 패턴
<br>ex) 트위터 포스팅 → 팔로워들에게 알림 
<br>주식 가격 변동에 따른 알림 → 다수의 투자자


<br>프록시

<br>다른 객체에 대한 접근을 제어하기 위한 대리자
<br>프록시 서버란? 서버 앞단에 둬서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 하는 서버. 
<br>ex) Nginx를 둬서 버퍼 overflow 해결
<br>포트 번호를 바꿔서 사용자가 실제 서버의 포트에 접근 불가능하도록
<br>공격자의 DDOS 공격을 차단하도록
<br>CDN을 프록시 서버로 달아서 캐싱 처리를 용이하도록 ex) CloudFlare


<br>이터레이터
<br>노출모듈
<br>MVC 

<br>Model-View-Controller pattern
<br>앱이 복잡해질 수록 Model과 View의 관계도 복잡해진다.


<br>MVP
<br>MVVM

<br>Model-View-View Model
<br>MVC패턴과 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징.


<br>1-2. 프로그래밍 패러다임<br>
<br>선언형 vs 함수형

<br>함수형 프로그래밍은 선언형 패러다임의 일부로 '무엇을' 풀어내는가에 집중.
<br>reduce와 같은 작은 순수 함수들을 블록처럼 쌓아서 프로그래밍한다.


<br>const ret = [1,2,3,4,5,11,12]
.reduce((max, num)=&gt; num &gt; max ? num : max, 0)

console.log(ret) // 12
Copy<br>
<br>객체지향

<br>객체들의 집합으로 프로그램의 상호작용을 표현한다.
<br>추상화, 캡슐화, 상속성, 다형성 ( <a href=".?query=tag:오버로딩" class="tag" target="_blank" rel="noopener">#오버로딩</a>, <a href=".?query=tag:오버라이딩" class="tag" target="_blank" rel="noopener">#오버라이딩</a> <a data-tooltip-position="top" aria-label="https://itpangpang.tistory.com/105" rel="noopener" class="external-link" href="https://itpangpang.tistory.com/105" target="_blank">참고</a> )
<br>SOLID 원칙


<br>절차형

<br>로직이 수행되어야 할 연속 계산 과정으로 이루어져 있다.
<br>과학 관련 연산 작업, 머신 러닝의 배치 작업


<br>패러다임의 혼합
<br><br><br>2-1. 네트워크의 기초<br>
<br>
네트워크란? 

<br>노드와 링크의 집합체


<br>
처리량과 지연 시간

<br>처리하는 데이터량 &amp; 처리하는 데 걸리는 속도


<br>
네트워크 토폴로지와 병목 현상

<br><a data-href="network topology.excalidraw" href="books/network-topology.excalidraw.html" class="internal-link" target="_self" rel="noopener">network topology.excalidraw</a>
<br>네트워크 토폴로지

<br>트리
<br>버스 - 여러 단말이 하나의 통신 매체를 공유한다.
<br>스타 - 각 단말이 개별적으로 통신 매체에 연결된다.
<br>링
<br>메시


<br>병목 현상


<br>
네트워크 분류

<br>
네트워크 성능 분석 명령어

<br>ping, netstat, nslookup, tracert


<br>
네트워크 프로토콜 표준화

<br>2-2. TCP/IP 4계층 모델<br>
<br>계층 구조

<br>TCP

<br><a href=".?query=tag:3-way-handshake" class="tag" target="_blank" rel="noopener">#3-way-handshake</a> handshak 과정을 통해 신뢰성이 구축된다.
<br>가상회선 패킨 교환 방식 (모든 패킷이 전송되면 가상회선이 해제되고 패킷은 전송된 순서대로 도착한다.)


<br>UDP

<br>데이터그램 패킷 교환 방식 (여러 패킷은 서로 다른 경로로 전송될 수 있으며 도착 순서가 다를 수 있다.)




<br>PDU
<br>2-3. 네트워크 기기<br>
<br>
네트워크 기기의 처리 범위

<br>애플리케이션 계층 : L7 스위치
<br>인터넷 계층 : Router, L3 스위치
<br>데이터 링크 계층 : Bridge, L2 스위치
<br>물리 계층 : NIC, Repeater, AP


<br>
애플리케이션 계층을 처리하는 기기

<br>L7 스위치 - 애플리케이션 Layer에서 동작.
<br>L7 vs L4 

<br>IP와 port 기반으로 동작하는 L4에 비해 L7은 IP, Port 외에도 url, http 헤더, 쿠키 등을 기반으로 트래픽을 분산한다.
<br>L7 로드밸런싱 (AWS ALB) vs L4 로드밸런싱 (AWS NLB)




<br>
인터넷 계층을 처리하는 기기

<br>L3 스위치 - L2 스위치 + Routing
<br>Router 

<br>패킷의 최적 경로를 탐색하여 해당 경로로 패킷을 포워딩하는 장비




<br>
데이터 링크 계층을 처리하는 기기

<br>Bridge 

<br>LAN끼리 연결하는 장비




<br>
물리 계층을 처리하는 기기

<br>NIC
<br>Repeater - 신호를 증폭시키는 기기
<br>AP (Access Point) - 패킷을 복사하는 기기


<br>2-4. IP주소<br>
<br>ARP
<br>HOP by HOP 통신
<br>IP 주소 체계
<br>IP 주소를 이용한 위치 정보
<br>2-5. HTTP<br>
<br>HTTP/1.0 

<br>요청과 응단 간에 연결을 매번 새로 열고 닫음.


<br>HTTP/1.1

<br>Keep-Alive 연결을 지원하여 여러 요청을 단일 연결로 처리 가능\
<br>헤더 압축 기능


<br>HTTP/2

<br>다중화(multiplexing)을 통해 여러 요청과 응답을 동시에 처리 가능
<br>Server Push 기능


<br>HTTPS

<br>보안이 강화된 HTTP 프로토콜로 SSL/TLS 암호화를 사용함.
<br>보안 인증서


<br>HTTP/3

<br>QUIC 프로토콜 기반으로 개발됨.
<br>TCP보다 빠른 데이터 전송 속도와 연결 설정


<br><br><br>3-1. 운영체제와 컴퓨터<br>
<br>운영체제의 역할과 구조
<br>컴퓨터의 요소
<br>3-2. 메모리<br>
<br>메모리 계층
<br>메모리 관리
<br>3-3. 프로세스와 스레드<br>
<br>프로세스와 컴파일 과정
<br>프로세스의 상태
<br>프로세스의 메모리 구조
<br>PCB
<br>멀티프로세싱
<br>스레드와 멀티스레딩
<br>공유 자원과 임계 영역
<br>교착상태
<br>3-4. CPU 스케줄링 알고리즘<br>
<br>비선점형 방식
<br>선점형 방식
<br><br><br>4-1. 데이터베이스의 기본<br>
<br>엔터티
<br>릴레이션
<br>속성
<br>도메인
<br>필드와 레코드
<br>관계
<br>키
<br>4-2. ERD의 정규화 과정<br>
4-3. 트랜잭션과 무결성<br>
4-4. DB의 종류<br>
4-5. 인덱스<br>
4-6. 조인의 종류<br>
4-7. 조인의 원리<br><br><br>5-1. 복잡도<br>
<br>시간 복잡도
<br>공간 복잡도
<br>자료 구조에서의 시간 복잡도
<br>5-2. 선형 자료 구조<br>
<br>연결 리스트
<br>배열
<br>벡터
<br>스택
<br>큐
<br>5-3. 비선형 자료 구조<br>
<br>그래프
<br>트리
<br>힙
<br>우선순위 큐
<br>맵
<br>셋
<br>해시 테이블
]]></description><link>books/면접을-위한-cs-전공지식-노트.html</link><guid isPermaLink="false">Books/면접을 위한 CS 전공지식 노트.md</guid><pubDate>Mon, 18 Mar 2024 00:23:36 GMT</pubDate><enclosure url="https://image.yes24.com/goods/108887922/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/108887922/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[시작하세요! 도커 쿠버네티스]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> <a class="tag" href="?query=tag:Docker_Swarm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker_Swarm</a> <a class="tag" href="?query=tag:Overlay_Network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Overlay_Network</a> <a class="tag" href="?query=tag:Namespace" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Namespace</a> <a class="tag" href="?query=tag:Deployment" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Deployment</a> <a class="tag" href="?query=tag:Pod" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Pod</a> <a class="tag" href="?query=tag:ReplicaSet" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ReplicaSet</a> <a class="tag" href="?query=tag:Deployment" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Deployment</a> <a class="tag" href="?query=tag:Service" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Service</a> <a class="tag" href="?query=tag:Namespace" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Namespace</a> <a class="tag" href="?query=tag:Mount" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mount</a> 
 <br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener">#docker</a> <a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> <a data-href="Kubernetes" href="docker-&amp;-k8s/kubernetes.html" class="internal-link" target="_self" rel="noopener">Kubernetes</a><br>
<img alt="100" src="https://image.yes24.com/goods/84927385/XL" referrerpolicy="no-referrer"><br><br><br>
<br>도커 볼륨 (-v)<br>
컨테이너의 데이터를 영속적 데이터로 활용할 수 있는 방법 중 하나.<br>
→ 1. 호스트와 볼륨을 공유 2. 볼륨 컨테이너 활용 3. 도커가 관리하는 볼륨 생성
<br>--mount 와 같은 역할을 한다.
<br>컨테이너가 아닌 외부에 데이터를 저장, 컨테이너는 그 데이터로 동작하도록 설계 → stateless
<br>즉, 컨테이너가 삭제되어도 데이터는 보존된다. 바람직한 설계 방법<br>
<br>
<br>도커의 구조<br>
→ 1. Docker as a client<br>
→ 2. Docker as a server : 실제로 컨테이너를 생성, 실행, 이미지를 관리하는 주체. <br> dockerd 프로세스로서 동작한다.<br>
<br>
<br>도커 데몬 (demon)<br>
도커 프로세스가 실행되어 서버로부터 입력 받을 준비가 된 상태.<br>
<br>
<br>컨테이너를 외부에 노출<br>
컨테이너도 가상 IP 주소를 할당받고, 도커의 경우 172.17.0.X 의 IP를 컨테이너에 할당한다. 그리고 이를 할당받은 eth0 인터페이스와 lo (로컬호스트) 인터페이스가 있다. <br> 외부에 이 앱을 노출하려면 eth0의 IP와 포트를 host의 IP와 포트에 바인딩해야 한다. <a data-href="포트포워딩.excalidraw" href="excalidraw/포트포워딩.excalidraw.html" class="internal-link" target="_self" rel="noopener">포트포워딩.excalidraw</a><br>
호스트의 포트 : 컨테이너의 포트
<br><br>가정)<br>
하나의 호스트 머신에서 구동하는 도커 엔진... CPU / Memory / Disk 용량 같은 자원이 부족해지면? → 여러 대의 서버를 클러스터로 만들어 자원을 병렬로 확장하는 방법이 있다. <br> 그러나 +a가 되었을 때 스케줄러, LB 문제, 클러스터 내 서버 다운 시 HA를 어떻게 보장할 지 이슈가 존재. 그 대안이 바로 <a href=".?query=tag:Docker_Swarm" class="tag" target="_blank" rel="noopener">#Docker_Swarm</a> <br>
<br>도커 스웜(docker swarm)을 사용하는 이유 - 여러 대의 docker 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 기능을 제공한다.
<br>스웜 클래식 
<br>도커 스웜 모드 MSA의 컨테이너를 다루기 위한 클러스터링 기능에 초점
<br><br>
<br>매번 run 명령어에 옵션을 설정해 CLI로 컨테이너를 생성하기보다는 여러 개의 컨테이너를 하나의 서비스로 정의해 묶음으로 관리하는 Docker Compose가 더 효율적이다.
<br>각 컨테이너의 의존성, 네트워크, 볼륨 등을 정의 가능하다.
<br>사용법 : run 명령어 → YAML
<br>구성 : version, service, volume, network 정의
<br><br>
<br>조타수를 의미하며 CNCF에 소속된 오픈소스이다.
<br>컨테이너 기반의 서비스 운영에 필요한 오케스트레이션 기능을 지원한다.
<br>여러 서버의 자원을 클러스터링해 컨테이너를 배치하는 것이 K8s의 핵심 기능.
<br>어떤 사용 환경? 

<br>클라우드 플랫폼 환경 (<a data-tooltip-position="top" aria-label="https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/what-is-eks.html" rel="noopener" class="external-link" href="https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/what-is-eks.html" target="_blank">EKS</a>, GKE, <a data-tooltip-position="top" aria-label="https://azure.microsoft.com/ko-kr/products/kubernetes-service" rel="noopener" class="external-link" href="https://azure.microsoft.com/ko-kr/products/kubernetes-service" target="_blank">AKS</a>, EC2와 같은 클라우드 서버 인프라에 K8s 설치)
<br>자체 서버 (on-premise)


<br>calico <a href=".?query=tag:Overlay_Network" class="tag" target="_blank" rel="noopener">#Overlay_Network</a> 
<br><br><br>
<br>
Pods : 컨테이너의 집합

<br>컨테이너 application의 기본 단위.
<br>Why not docker container? → 리눅스 <a href=".?query=tag:Namespace" class="tag" target="_blank" rel="noopener">#Namespace</a> 를 공유하는 여러 컨테이너들을 추상화된 집합으로 사용하기 위함.
<br>포드에 정의된 여러 개의 컨테이너는 하나의 완전한 애플리케이션으로 동작함.


<br>
Replica Set : Pods를 관리하는 컨트롤러

<br>일정 개수의 포드를 유지하는 컨트롤러


<br>
Deployment : Replica Set, Pod의 배포를 관리

<br>Replica Set의 상위 오브젝트

<br>Why Replica Set 있는데 deployment를 쓰나? → 애플리케이션의 업데이트와 배포를 더욱 편하게 만들기 위해서. (for rollback, rolling update <a href=".?query=tag:Deployment" class="tag" target="_blank" rel="noopener">#Deployment</a> )




<br>
Service : Pod를 연결하고 외부에 노출

<br>K8s에서는 Pod에 접근하도록 어떻게 정의하나?

<br>docker의 경우, -p 옵션을 사용하면 컨테이너를 외부로 노출할 수 있다. (= container 생성과 동시에 외부로 노출되는 방식)


<br>Cluster IP type : 쿠버네티스 내부에서만 접근 가능
<br>Node Port type : 클러스터 외부에서도 접근 가능 (모든 Node의 특정 Port를 개방해 서비스에 접근) 

<br>Cluster IP 의 기능 포함 (내부 접근)


<br>Load Balancer type : 서비스 생성과 동시에 로드 밸런서를 새롭게 생성해 포드와 연결 → 모든 worker node는 포드에 접근할 수 있는 random port를 개방한다. 

<br>Cluster IP의 기능을 포함
<br>NodePort의 간접적인 기능을 자동으로 사용 가능하다.
<br>L4 로드밸런서 <a data-href="OSI 7 Layer" href="osi-7-layer.html" class="internal-link" target="_self" rel="noopener">OSI 7 Layer</a>


<br>External Name type : 서비스가 외부 도메인을 가리키도록 설정 가능.

<br>외부 시스템과의 연동이 필요할 때




<br><br>
<br>Master Node : 쿠버네티스가 동작할 수 있게 클러스터를 관리

<br>API server
<br>CM (controller manager)
<br>Scheduler


<br>kubelet : 컨테이너 생성, 삭제, Master-Worker Node 간 통신을 담당하는 agent
<br>Worker Node : application container가 생성된다.
<br><br>
<br>K8s에서 앱을 배포하기 위한 필수 요소 4 
<br><a href=".?query=tag:Pod" class="tag" target="_blank" rel="noopener">#Pod</a> / <a href=".?query=tag:ReplicaSet" class="tag" target="_blank" rel="noopener">#ReplicaSet</a> / <a href=".?query=tag:Deployment" class="tag" target="_blank" rel="noopener">#Deployment</a> / <a href=".?query=tag:Service" class="tag" target="_blank" rel="noopener">#Service</a> 
<br><a href=".?query=tag:Namespace" class="tag" target="_blank" rel="noopener">#Namespace</a> : 리소스를 구분하는 장벽 (ns)
<br>Configmap (cm), Secret - 설정 값을 포드에 전달

<br>애플리케이션과 설정값을 별도로 분리해 관리할 수 있다.
<br>데이터를 yaml 파일로부터 분리할 수 있는 kustomize 기능 (자주 사용되는 yaml 파일의 속성을 별도로 정의해 재사용 or 여러 yaml 파일을 하나로 묶음)


<br><br><br>
<br>외부 → 내부로 향하는 것을 지칭한다.
<br>L7 로드밸런서
<br>url 하나로 접근
<br>라우팅 정의나 보안 연결과 같은 세부 설정 (외부 요청에 대한 처리 규칙)이 수행된다.

<br>Why needed? 서비스마다 세부적인 설정을 할 때 추가적인 복잡성이 발생하게 됨. ex) SSL/TLS 보안 연결, 접근 도메인 및 Client 상태에 기반한 라우팅


<br>ingress controller 서버가 반드시 필요하다.

<br>Nginx web server ingress controller


<br><br>
<br>
DB 처럼 포드 내부에서 특정 데이터를 보유해야 하는 경우

<br>
deployment 삭제 → pod + pod의 data 삭제 → 포드의 데이터를 영속적으로 저장하기 위한 방법인 PV 필요

<br>
PV (Persistent Volume) - 워커 노드들이 네트워크 상에서 storage를 mount해 영속적으로 데이터를 저장할 수 있는 볼륨

<br>NFS (Network File System), AWS EBS (Elastic Block Store), Ceph, GlusterFS 
<br>PV 사용이 끝났을 때 해당 볼륨을 어떻게 초기화할 것인지 Reclaim Policy

<br>Retain
<br>Delete
<br>Recycle




<br>
PVC (Persistent Volume Claim) - 사용자가 PV에 하는 요청

<br>
로컬 볼륨 

<br>hostPath : host와 볼륨을 공유하기 위해서 사용
<br>emptyDir : pod의 컨테이너 간에 볼륨을 공유하기 위해서 사용 (Pod가 실행되는 도중에만 필요한 휘발성 데이터를 각 컨테이너가 함께 사용할 수 있도록 임시 저장 공간을 생성)


<br>
다이나믹 프로비저닝 (Dynamic Provisioning) : PVC이 요구하는 조건과 일치하는 PV가 존재하지 않으면 자동으로 PV와 외부 storage를 함께 provisioning 하는 기능

<br><br>
<br>Service Account (sa) : 권한을 관리하기 위한 Kubernetes Object
<br>권한 부여 방식

<br>Role
<br>Cluster Role
<br>Cluster Role Aggregation


<br>Pod를 생성할 때 자동으로 service account의 secret을 pod 내부에 <a href=".?query=tag:Mount" class="tag" target="_blank" rel="noopener">#Mount</a> 한다.
<br><br><br><br>]]></description><link>books/시작하세요!-도커-쿠버네티스.html</link><guid isPermaLink="false">Books/시작하세요! 도커 쿠버네티스.md</guid><pubDate>Sun, 10 Mar 2024 07:09:34 GMT</pubDate><enclosure url="https://image.yes24.com/goods/84927385/XL" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.yes24.com/goods/84927385/XL"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Disk가 아닌 주 Memory에 데이터를 저장하는 Database.]]></title><description><![CDATA[ 
 <br><br>🔑 꺼지면, 날아간다!<br>In-Memory Database =<br>
MMDB(Main Memory&nbsp;<a data-tooltip-position="top" aria-label="https://namu.wiki/w/DBMS" rel="noopener" class="external-link" title="DBMS" href="https://namu.wiki/w/DBMS" target="_blank">DBMS</a>)<br>Redis]]></description><link>database/in-memory-db.html</link><guid isPermaLink="false">Database/In-Memory DB.md</guid><pubDate>Fri, 12 Jan 2024 09:29:52 GMT</pubDate></item><item><title><![CDATA[<a data-tooltip-position="top" aria-label="https://namu.wiki/w/NoSQL" rel="noopener" class="external-link" title="NoSQL" href="https://namu.wiki/w/NoSQL" target="_blank">NoSQL</a>&nbsp;<a data-tooltip-position="top" aria-label="https://namu.wiki/w/DBMS" rel="noopener" class="external-link" title="DBMS" href="https://namu.wiki/w/DBMS" target="_blank">DBMS</a>의 한 종류.]]></title><description><![CDATA[<a class="tag" href="?query=tag:Scale-out" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Scale-out</a> 
 <br><br><br>
<br>Document : 정렬된 key, value의 집합. 가장 기본적인 data
<br>Collection : document의 모음. RDBMS로 치면 Table. 동적 schema를 가진다.
<br>Database
<br>id : document의 Primary key
<br><br>
<br>Document Database (JSON처럼 키-밸류(Key-Value) 조합 그대로 저장할 수 있는 문서 형식의 DB)
<br>value의 형태는 동적으로 변경 가능하다. Schemaless
<br>NoSQL이면서 Index를 지원한다.
<br>특수 쿼리 
<br>가용성
<br><a href=".?query=tag:Scale-out" class="tag" target="_blank" rel="noopener">#Scale-out</a> <a data-href="Sharding" href="database/sharding.html" class="internal-link" target="_self" rel="noopener">Sharding</a>
<br><br>
<br>database 생성 or 선택 : use db명
<br>database 확인 : show dbs
<br>collection 생성 : db.createCollection('컬렉션명')
<br>collection 확인 : show collections
<br>collection 삭제 : db.컬렉션명.drop()
<br>database 삭제 : db.dropDatabase()
<br>database 로그인 : db.auth('ID','Password)
<br><br>
<br>~~db.collection.insert()
<br><br>$ brew tap mongodb/brew
$ brew install mongodb-community@6.0

$ brew services start mongodb-community@6.0
Copy<br>
<br>접속 확인<br>
http://localhost:27017 으로 접속하면 아래의 문구 출력됨 → 정상 동작한다는 의미이다.
<br>It looks like you are trying to access MongoDB over HTTP on the native driver port.
Copy<br>
<br>mongo 6.0 이상 ver ↓
<br>$ mongosh
Copy<br>
<br>mongo 6.0 이전 ver ↓
<br>$ brew install mongodb-community-shell
$ mongo
Copy]]></description><link>database/mongodb.html</link><guid isPermaLink="false">Database/MongoDB.md</guid><pubDate>Thu, 11 Jan 2024 00:35:02 GMT</pubDate></item><item><title><![CDATA[데이터를 복수 서버에 분산시키는 <strong>수평적 확장</strong> 구조]]></title><description><![CDATA[<a class="tag" href="?query=tag:sharding" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#sharding</a> <a class="tag" href="?query=tag:Scale-out" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Scale-out</a> <a class="tag" href="?query=tag:Scale-up" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Scale-up</a> 
 <br><a href=".?query=tag:sharding" class="tag" target="_blank" rel="noopener">#sharding</a><br><br>대규모 데이터 set을 처리하기 위해 데이터를 여러 개의 작은 partition/shard로 나누는 것<br><br>
<br>수평적 확장 <a href=".?query=tag:Scale-out" class="tag" target="_blank" rel="noopener">#Scale-out</a>

<br>더 강력한 CPU를 사용하거나 RAM을 추가. 저장 공간을 늘린다.
<br>단일 서버의 용량을 늘리는 작업


<br>수직적 확장 <a href=".?query=tag:Scale-up" class="tag" target="_blank" rel="noopener">#Scale-up</a>

<br>시스템 Dataset와 로드를 여러 서버로 나누고, 필요에 따라 서버를 추가하여 용량 증설한다.
<br>단일 시스템의 속도나 용량은 그리 높지 않더라도 부하 분산을 고려하면 더 효율적인 방법이라고 볼 수 있다. 다만 복잡성의 이슈가 있다.


]]></description><link>database/sharding.html</link><guid isPermaLink="false">Database/Sharding.md</guid><pubDate>Sun, 14 Jan 2024 14:53:36 GMT</pubDate></item><item><title><![CDATA[Data를 벡터 형태로 저장하고 관리하기 위해 특화된 DB]]></title><description><![CDATA[ 
 <br><br><br>ANN(Approximate Nearest Neighbor) 알고리즘(예: Locality-Sensitive Hashing 또는 Product Quantization)과 같은 인덱싱 기술을 사용하여 검색 프로세스를 가속화<br><br>
<br>Vespa
<br>Pinecone
<br>Milvus
<br>Redis, MongoDB, Cosmos DB, Cassandra → 벡터 지원&nbsp;NoSQL 데이터베이스
<br>PostgreSQL
<br><br>장점<br>
<br>고차원 벡터 (단 하나의 숫자로 나타낼 수 없는 양) 데이터의 효율적인 저장, 검색, 유사성 검색
<br>단점<br>
<br>이 vector DB가 차지하는 메모리가 큰 편에 속함
<br>embedding을 해서 indexing 하는 데에 많은 시간이 소요되고, cost가 매우 높은 편.
<br><br><a data-tooltip-position="top" aria-label="https://velog.io/@tura/vector-databases" rel="noopener" class="external-link" href="https://velog.io/@tura/vector-databases" target="_blank">Vector DB란?</a><br>
<a data-tooltip-position="top" aria-label="https://www.linkedin.com/pulse/choosing-vector-database-your-gen-ai-stack-abhinav-srivastava/" rel="noopener" class="external-link" href="https://www.linkedin.com/pulse/choosing-vector-database-your-gen-ai-stack-abhinav-srivastava/" target="_blank">Vector DB 종류</a><br>
<a data-tooltip-position="top" aria-label="https://hotorch.tistory.com/406" rel="noopener" class="external-link" href="https://hotorch.tistory.com/406" target="_blank">Vector DB 종류&amp;한계점</a>]]></description><link>database/vector-db.html</link><guid isPermaLink="false">Database/Vector DB.md</guid><pubDate>Fri, 12 Jan 2024 09:26:58 GMT</pubDate></item><item><title><![CDATA[쿠버네티스 환경에서의 Application 배포와 관리를 지원하는 GitOps CD tool]]></title><description><![CDATA[<a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> <a class="tag" href="?query=tag:ArgoCD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ArgoCD</a> 
 <br><a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> <a href=".?query=tag:ArgoCD" class="tag" target="_blank" rel="noopener">#ArgoCD</a><br><br>🔑 ArgoCD로 K8s 클러스터 내 리소스를 관리한다.<br>
(yaml 파일 작성 → application 세팅이 선행되어야 한다.)<br>이 yaml 파일을 Manifest라고 하는데, ArgoCD는 이 파일의 변경사항을 감시하여 현재 배포된 환경의 상태와 Manifest에 정의된 상태를 동일하게 유지한다.<br>observe<br><br>
<br>2개의 클러스터 생성할 건데, 하나는 for ArgoCD, 다른 하나는 for application push &amp; run
<br>$ brew install minikube
$ minikube start -p target-k8s
$ minikube start -p argocd-k8s

$ kubectl create namespace argocd
$ kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
$ watch kubectl get pods -n argocd
Copy<br>watch가 없다면 설치한다.<br>
watch는 특정 실행 명령어를 지속적으로 모니터링이 가능하다.<br>$ brew install watch
Copy<br>클러스터 외부에서는 액세스할 수 없습니다.&nbsp;데모 환경이므로 포트포워딩을 해서 포트를 서비스에 노출시킨다.<br>$ kubectl port-forward svc/argocd-server -n argocd 8080:443
Copy<br>https://localhost:8080 에 접속하면 다음과 같은 UI를 확인 가능하다.<br>
Argo CD는 최초&nbsp;admin&nbsp;account의 초기 password를 K8s 의 secret 으로 저장해 놓는다.<br>$ kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo
Copy<br>ArgoCD CLI를 설치한 후 로그인을 한다.<br>
참고&nbsp;: UI와 마찬가지로 서버 인증서 오류를 수락해야 한다.<br>$ brew tap argoproj/tap &amp;&amp; brew install argoproj/tap/argocd
$ argocd login localhost:8080

Copy<br>https://localhost:8080/applications<br>
로 접속해보면 UI가 정상적으로 뜬다.<br>(선택) 원한다면 password를 변경할 수도 있다.<br>$ argocd account update-password
Copy<br><br>curl 로 설치 필요<br>
<a rel="noopener" class="external-link" href="https://medium.com/google-cloud/configuring-argocd-on-gke-with-ingress-and-github-sso-bf7868942403" target="_blank">https://medium.com/google-cloud/configuring-argocd-on-gke-with-ingress-and-github-sso-bf7868942403</a><br>kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'<br>
external IP로 접속<br><br><a data-tooltip-position="top" aria-label="https://tanzu.vmware.com/developer/guides/argocd-gs/" rel="noopener" class="external-link" href="https://tanzu.vmware.com/developer/guides/argocd-gs/" target="_blank">Tanzu Developer Center</a><br>
<a data-tooltip-position="top" aria-label="https://medium.com/delightroom/%EB%94%9C%EB%9D%BC%EC%9D%B4%ED%8A%B8%EB%A3%B8-devops-1%ED%83%84-argo-cd-%EB%84%8C-%EB%AD%90%EB%8B%88-59f453ceb590" rel="noopener" class="external-link" href="https://medium.com/delightroom/%EB%94%9C%EB%9D%BC%EC%9D%B4%ED%8A%B8%EB%A3%B8-devops-1%ED%83%84-argo-cd-%EB%84%8C-%EB%AD%90%EB%8B%88-59f453ceb590" target="_blank">딜라이트룸 DevOps</a>]]></description><link>docker-&amp;-k8s/argocd.html</link><guid isPermaLink="false">Docker &amp; K8s/ArgoCD.md</guid><pubDate>Mon, 05 Feb 2024 09:04:54 GMT</pubDate></item><item><title><![CDATA[앱을 어떠한 환경에서든 신속하게 <strong>배포</strong>, <strong>확장</strong>, <strong>실행</strong>될 수 있도록 하는 서비스를 제공하는 s/w 플랫폼.]]></title><description><![CDATA[<a class="tag" href="?query=tag:Docker_Swarm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Docker_Swarm</a> <a class="tag" href="?query=tag:Mount" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Mount</a> <a class="tag" href="?query=tag:container" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#container</a> 
 <br><br>
<br>리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 s/w 플랫폼.
<br>Docker는 Host OS의 커널 위에 격리를 시켜주는 반가상화 시스템
<br>Docker 컨테이너는 Host 시스템의 리소스를 공유하고 격리된 환경에서 실행된다.
<br><br>
<br>Bridge : 기본 네트워크 유형으로, host 내부의 개인 네트워크 격리와 보안
<br>Host : docker host의 네트워크 stack을 공유하며 격리 없이 직접 통신 가능 (= Docker host와 Docker container 간의 네트워크 격리를 제거) 통신의 용이성 &amp; 네트워크 대기 시간을 단축
<br>Overlay : 서로 다른 host에서 실행되는 Docker container가 마치 동일한 host에서 있는 것처럼 통신 가능 ( <a href=".?query=tag:Docker_Swarm" class="tag" target="_blank" rel="noopener">#Docker_Swarm</a>)
<br><br>
<br>docker (container) ps<br>
현재 실행 중인 Docker container들의 목록 확인
<br>docker (container) stop $container_id<br>
지정된 컨테이너 중지
<br>docker (container) rm $container_id<br>
지정된 컨테이너 삭제
<br>docker (contaIner) rm -f $container_id<br>
실행 중인 컨테이너 강제 삭제. docker kill + docker rm
<br>docker (container) prune<br>
중지된 컨테이너만 일괄 삭제
<br><br>
<br>base image로 <a data-tooltip-position="top" aria-label="https://namu.wiki/w/Alpine%20Linux" rel="noopener" class="external-link" href="https://namu.wiki/w/Alpine%20Linux" target="_blank">alpine</a> 을 사용한다.
<br>multi stage build를 활용한다.
<br>불필요한 layer의 수를 줄인다.
<br>.dockerignore를 활용한다.
<br>application data를 별도 volume으로 분리한다.
<br><br>
<br>docker run 명령어는 새로운 컨테이너를 생성하고 실행하는 데 사용.<br>
이미지 → 컨테이너로 변환되어 하나의 인스턴스화
<br>docker exec 명령어는 이미 실행 중인 컨테이너에서 추가적인 프로세스나 명령을 실행하는 데 사용.<br>
docker exec -it $container_id bash
<br><br>
<br>여러 도커 컨테이너를 조합해서 기동할 수 있도록 만든 개발자용 오케스트레이션 tool (=상호 의존하는 여러 도커 컨테이너를 빌드하여 실행한다.)
<br><br>
<br>복수의 노드로 클러스터를 구성하는 tool
<br><a href=".?query=tag:Mount" class="tag" target="_blank" rel="noopener">#Mount</a><br>
<br>마운트
<br>호스트의 파일 시스템 경로를 컨테이너 내부에 연결하는 것
<br><br>
<br>이식성

<br>어떤 OS 환경에서든 동일하게 동작한다. (environment disparity 해결)


<br>자원 효율성 ( 🔑 더 가볍고 빠르게 실행된다.)

<br>모든 dependency, code를 <a href=".?query=tag:container" class="tag" target="_blank" rel="noopener">#container</a> 에 패키징한다. VM보다 훨씬 적은 자원을 사용하고 가볍다. (VM 대비해서 Guest OS layer가 없기 때문에 적은 overhead, 작은 이미지 사이즈 &gt; 부팅이 빠르다. 하나의 Host OS를 공유하고, 이 커널 위에 개별 프로세스와 환경을 격리화 시키는 방식이다.)


<br>배포 관리 용이성

<br>여러 컨테이너로 구성된 애플리케이션을 쉽게 관리 가능하다. ex) docker compose


<br>VM<br>
<img alt="vm" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F213CAE3D5265549405" referrerpolicy="no-referrer" style="width: 350px; max-width: 100%;">
<br>Docker<br>
<img alt="docker" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F272F203F5265549F04" referrerpolicy="no-referrer" style="width: 350px; max-width: 100%;">
<br><br>
<br>Local에서 돌려본다.<br>
Amazon ECS에 프로비저닝하기 전에 컨테이너를 로컬에서 테스트하여 컨테이너 상태 확인을 통과하는지 확인 ex) Dockerfile health check
<br>Log를 확인한다.<br>
Amazon ECS 작업이 오랜 시간 동안 계속 실행되는 경우 애플리케이션 로그와 Amazon CloudWatch Logs를 확인
<br><br><a data-tooltip-position="top" aria-label="https://docs.docker.com/" rel="noopener" class="external-link" href="https://docs.docker.com/" target="_blank">Docker 공식문서</a><br>
<a data-tooltip-position="top" aria-label="https://ivdevlog.tistory.com/9" rel="noopener" class="external-link" href="https://ivdevlog.tistory.com/9" target="_blank">Docker CMD &amp; elements</a><br>
<a data-tooltip-position="top" aria-label="https://www.appsdeveloperblog.com/docker-networking-bridging-host-and-overlay/#Understanding_Docker_Networking" rel="noopener" class="external-link" href="https://www.appsdeveloperblog.com/docker-networking-bridging-host-and-overlay/#Understanding_Docker_Networking" target="_blank">Docker Network - bridge, host, overlay</a>]]></description><link>docker-&amp;-k8s/docker.html</link><guid isPermaLink="false">Docker &amp; K8s/Docker.md</guid><pubDate>Wed, 13 Mar 2024 00:49:52 GMT</pubDate><enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F213CAE3D5265549405" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F213CAE3D5265549405"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[다중 컨테이너 Docker 애플리케이션을 정의하고 실행하기 위한 도구]]></title><description><![CDATA[ 
 <br><br><a rel="noopener" class="external-link" href="https://www.daleseo.com/docker-compose/" target="_blank">https://www.daleseo.com/docker-compose/</a><br>yaml를 설정 파일로 사용<br> docker-compose -f 
Copy<br>모든 서비스 컨테이너를 한 번에 생성하고 실행<br>
-d&nbsp;옵션을 사용하여 백그라운드에서 컨테이너를 띄우는 경우<br>$ docker-compose up -d
Copy<br>(-d&nbsp;옵션을 사용하지 않으면 현재 터미널에 컨테이너의 로그가 출력되고&nbsp;<br>
Ctrl + C를 눌러서 탈출하는 순간 컨테이너가 모두 정지되기 때문이다.)<br>모든 서비스 컨테이너를 한 번에 정지시키고 삭제<br>$ docker-compose down
Copy<br>내려가 있는 있는 특정 서비스 컨테이너를 올리기 위해서 사용한다.<br>$ docker-compose start
Copy<br>돌아기고 있는 특정 서비스 컨테이너를 정지시키기 위해서 사용<br>$ docker-compose stop
Copy<br>서비스 컨테이너의 특정 명령어를 일회성으로 실행<br>$ docker-compose run
Copy]]></description><link>docker-&amp;-k8s/docker-compose.html</link><guid isPermaLink="false">Docker &amp; K8s/Docker Compose.md</guid><pubDate>Tue, 09 Jan 2024 08:54:43 GMT</pubDate></item><item><title><![CDATA[GKE]]></title><description><![CDATA[ 
 <br><br>
<br>기본적으로 API 활성화가 필요함.<br>
Kubernetes Engine API
<br>$ gcloud services enable compute.googleapis.com container.googleapis.com
Copy<br><a data-tooltip-position="top" aria-label="https://cloud.google.com/kubernetes-engine/docs/resources/autopilot-standard-feature-comparison?hl=ko" rel="noopener" class="external-link" href="https://cloud.google.com/kubernetes-engine/docs/resources/autopilot-standard-feature-comparison?hl=ko" target="_blank">GKE autopilot</a> + Google Cloud Run &gt; EKS와 Fargate의 조합과 유사<br>
<br>GKE autopiloat

<br>자동 관리 (Node Scaling)
<br>리소스 최적화


<br>Google Cloud Run

<br>서버리스 컴퓨팅
<br>auto scaling
<br>간편한 배포
<br>보안 및 격리


<br><br>
<br><a data-tooltip-position="top" aria-label="https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/using_gke_with_terraform" rel="noopener" class="external-link" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/using_gke_with_terraform" target="_blank">Terraform Docs</a>
<br><br><a data-tooltip-position="top" aria-label="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app?hl=ko#cloud-shell" rel="noopener" class="external-link" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app?hl=ko#cloud-shell" target="_blank">컨테이너화된 웹 애플리케이션 배포</a>]]></description><link>docker-&amp;-k8s/gke.html</link><guid isPermaLink="false">Docker &amp; K8s/GKE.md</guid><pubDate>Thu, 18 Jan 2024 02:21:17 GMT</pubDate></item><item><title><![CDATA[<a data-href="Kubernetes" href="docker-&amp;-k8s/kubernetes.html" class="internal-link" target="_self" rel="noopener">Kubernetes</a>에서 애플리케이션을 쉽게 배포하기 위해 사용되는 대표적인 패키지 매니저]]></title><description><![CDATA[<a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> 
 <br><a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> <br><br><br>
<br>Micro service 배포 시 공통된 하나의 template (yaml) 을 정의해두고, 그 안의 value만 수정하여 서비스 배포 시 재 사용이 가능하다.
<br><br>
<br>Helm package. 
<br>K8s 클러스터 내에서 애플리케이션, 도구, 서비스 구동하는데 필요한 모든 리소스 정의가 포함되어 있다.
<br>apiVersion: The chart API version (required)
name: The name of the chart (required)
version: A SemVer 2 version (required)
kubeVersion: A SemVer range of compatible Kubernetes versions (optional)
description: A single-sentence description of this project (optional)
type: The type of the chart (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this projects home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
dependencies: # A list of the chart requirements (optional)
  - name: The name of the chart (nginx)
    version: The version of the chart ("1.2.3")
    repository: (optional) The repository URL ("https://example.com/charts") or alias ("@repo-name")
    condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )
    tags: # (optional)
      - Tags can be used to group charts for enabling/disabling together
    import-values: # (optional)
      - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.
    alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times
maintainers: # (optional)
  - name: The maintainers name (required for each maintainer)
    email: The maintainers email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended.
deprecated: Whether this chart is deprecated (optional, boolean)
annotations:
  example: A list of annotations keyed by name (optional).

Copy<br>
<br>type 

<br>application
<br>library


<br>dependencies : 하나의 차트가 여러 차트에 종속될 수 있음.
<br><br>
<br>차트를 모아두고 공유하는 장소
<br><br>
<br>K8s 클러스터에서 구동되는 차트의 인스턴스.
<br><br>
<br>Helm get manifest Release Name
<br>Helm status Release Name
<br>Helm install  Release Name
<br>Helm uninstall  Release Name
<br>Helm repo add Release Name
<br>Helm repo update
<br>Helm repo list
<br><br>
<br>upgrade - 새로운 버전의 차트가 release 되었을 때, release의 구성을 변경하고자 할 때
<br>rollback
<br><br><a data-tooltip-position="top" aria-label="https://github.com/argoproj/argo-helm/tree/main/charts/argo-cd" rel="noopener" class="external-link" href="https://github.com/argoproj/argo-helm/tree/main/charts/argo-cd" target="_blank">Argo-Helm</a><br>brew install minikube
minikube start

kubectl create ns argocd
helm repo add argo https://argoproj.github.io/argo-helm

Copy<br>Helm v3 vs v2<br>
<br>Tiller가 v3에서는 사라졌다.
<br>helm은 K8s 내부에 charts를 설치하고, 각 설치에 대해 새로운 release를 생성한다. <br> 새로운 chart를 찾기 위해 Helm Chart Repository를 검색할 수 있다.<br><br><a data-tooltip-position="top" aria-label="https://helm.sh/" rel="noopener" class="external-link" href="https://helm.sh/" target="_blank">Helm 공식 Docs</a><br>
<a data-tooltip-position="top" aria-label="https://github.com/mincloud1501/Helm" rel="noopener" class="external-link" href="https://github.com/mincloud1501/Helm" target="_blank">Helm 실습</a>]]></description><link>docker-&amp;-k8s/helm.html</link><guid isPermaLink="false">Docker &amp; K8s/Helm.md</guid><pubDate>Fri, 19 Jan 2024 07:07:41 GMT</pubDate></item><item><title><![CDATA[<a data-href="Helm" href="docker-&amp;-k8s/helm.html" class="internal-link" target="_self" rel="noopener">Helm</a> 으로 <a data-href="ArgoCD" href="docker-&amp;-k8s/argocd.html" class="internal-link" target="_self" rel="noopener">ArgoCD</a>를 배포하는 경우]]></title><description><![CDATA[<a class="tag" href="?query=tag:선언적" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#선언적</a> <a class="tag" href="?query=tag:명령적" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#명령적</a> 
 <br><br>
<br>장점:

<br>간편한 패키징: Helm은 애플리케이션을 패키지로 간편하게 묶을 수 있습니다.
<br>커뮤니티 지원: Helm은 큰 커뮤니티와 다양한 차트를 통해 지원을 받을 수 있습니다.
<br>템플릿화: Helm은 템플릿을 사용하여 배포 구성을 생성할 수 있습니다.


<br>단점:

<br>Imperative Configuration: Helm은 주로 명령형 구성을 사용하므로 코드와 배포 구성이 섞일 수 있습니다.
<br>GitOps의 미비: Helm 자체는 GitOps에 적합하지 않을 수 있습니다.


<br><br>
<br>장점

<br>Declarative Configuration: ArgoCD는 애플리케이션 배포를 선언적으로 정의할 수 있습니다.
<br>GitOps: 배포 구성이 Git 저장소에 저장되어 코드와 함께 관리될 수 있습니다.
<br>UI 및 CLI: ArgoCD는 직관적인 UI와 CLI를 제공하여 쉽게 사용할 수 있습니다.
<br>쉬운 롤백: 이전 상태로 쉽게 롤백할 수 있습니다.


<br>단점

<br>복잡성: ArgoCD는 특정 케이스에서 배포 구성을 정의하는 데 복잡할 수 있습니다.


<br><a href=".?query=tag:선언적" class="tag" target="_blank" rel="noopener">#선언적</a> <a href=".?query=tag:명령적" class="tag" target="_blank" rel="noopener">#명령적</a><br>
<br>k8s 같은 시스템의 경우 선언적 접근이 선호됨. 목표 상태만 명시하면 됨.
<br>Kubernetes의 YAML 파일에서 리소스를 정의하는 것
]]></description><link>docker-&amp;-k8s/helm-with-argocd.html</link><guid isPermaLink="false">Docker &amp; K8s/Helm with ArgoCD.md</guid><pubDate>Fri, 19 Jan 2024 07:26:37 GMT</pubDate></item><item><title><![CDATA[Object]]></title><description><![CDATA[<a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> <a class="tag" href="?query=tag:Namespace" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Namespace</a> 
 <br><a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> <br><br><a data-href="Kubernetes" href="docker-&amp;-k8s/kubernetes.html" class="internal-link" target="_self" rel="noopener">Kubernetes</a> 시스템에서 영속성을 가지는 오브젝트<br>
<br>오브젝트 spec
<br>오브젝트 status
<br>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
Copy<br>
<br>apiVersion&nbsp;- 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지
<br>kind&nbsp;- 어떤 종류의 오브젝트를 생성하고자 하는지
<br>metadata&nbsp;-&nbsp;이름&nbsp;문자열,&nbsp;UID, 그리고 선택적인 <a href=".?query=tag:Namespace" class="tag" target="_blank" rel="noopener">#Namespace</a> 를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터
<br>spec&nbsp;- 오브젝트에 대해 어떤 상태를 의도하는지
<br><br><a data-tooltip-position="top" aria-label="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener" class="external-link" href="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank">쿠버네티스 오브젝트 이해하기</a>]]></description><link>docker-&amp;-k8s/k8s-object.html</link><guid isPermaLink="false">Docker &amp; K8s/K8s Object.md</guid><pubDate>Wed, 17 Jan 2024 08:44:11 GMT</pubDate></item><item><title><![CDATA[MySQL]]></title><description><![CDATA[ 
 <br><br>MySQL&nbsp;deployment on a Kubernetes cluster using the&nbsp;Helm&nbsp;package manager<br>Initialize a Helm Chart Repository<br>helm version
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo list
Copy<br>Install Mysql Chart<br>kubectl create ns database
kubectl get ns

helm install -ns database mysql bitnami/mysql
MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace database mysql -o jsonpath="{.data.mysql-root-password}" | base64 -d)
echo $MYSQL_ROOT_PASSWORD
pI3O0ZOt4J

kubectl run mysql-client --rm --tty -i --restart='Never' --image  docker.io/bitnami/mysql:8.0.36-debian-11-r0 --namespace database --env MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD --command -- bash

mysql -h mysql.database.svc.cluster.local -uroot -p"$MYSQL_ROOT_PASSWORD"
Copy<br>ctrl + D 2번 눌러 빠져 나간다.<br>namespace database에 배포된 리소스 확인 및 포트 포워딩을 통한 접속 확인 <br>helm ls --namespace database
kubectl get po -n database
kubectl port-forward mysql-0 3306:3306 -n database
mysql -u root -h 127.0.0.1 -p

Copy<br><br>PostgreSQL&nbsp;deployment on a Kubernetes cluster using the&nbsp;Helm&nbsp;package manager<br>helm version
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo list

kubectl create ns database

# helm install &lt;name&gt; bitnami/postgresql -–namespace &lt;namespace&gt;
helm install postgresql bitnami/postgresql -–namespace database
export POSTGRES_PASSWORD=$(kubectl get secret --namespace database postgresql -o jsonpath="{.data.postgres-password}" | base64 -d)
echo $POSTGRES_PASSWORD
azFVFQ4NT0

kubectl run postgresql-client --rm --tty -i --restart='Never' --namespace database --image docker.io/bitnami/postgresql:16.1.0-debian-11-r23 --env="PGPASSWORD=$POSTGRES_PASSWORD" \
--command -- psql --host postgresql -U postgres -d postgres -p 5432

# to connect to db from outside the cluster
kubectl port-forward --namespace database svc/postgresql 5432:5432 &amp;
    PGPASSWORD="$POSTGRES_PASSWORD" psql --host 127.0.0.1 -U postgres -d postgres -p 5432

# 확인
\list

# 빠져나오기
exit

kubectl get po -n database

Copy<br><br><br><br><br>
<br><a data-tooltip-position="top" aria-label="https://dev-scratch.tistory.com/179" rel="noopener" class="external-link" href="https://dev-scratch.tistory.com/179" target="_blank">[Kubernetes] 쿠버네티스에 데이터베이스 배포하고 애플리케이션 연결하기(Secret 사용)</a>
<br><a data-tooltip-position="top" aria-label="https://pyrasis.com/jHLsAlwaysUpToDateKubernetes/Unit08/02" rel="noopener" class="external-link" href="https://pyrasis.com/jHLsAlwaysUpToDateKubernetes/Unit08/02" target="_blank">Helm으로 MySQL 설치하기</a>
]]></description><link>docker-&amp;-k8s/k8s에-db-배포.html</link><guid isPermaLink="false">Docker &amp; K8s/K8s에 DB 배포.md</guid><pubDate>Tue, 30 Jan 2024 06:21:52 GMT</pubDate></item><item><title><![CDATA[컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼]]></title><description><![CDATA[<a class="tag" href="?query=tag:Pod" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Pod</a> <a class="tag" href="?query=tag:Service" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Service</a> <a class="tag" href="?query=tag:ReplicaSet" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ReplicaSet</a> <a class="tag" href="?query=tag:Namespace" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Namespace</a> <a class="tag" href="?query=tag:Cluster" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Cluster</a> <a class="tag" href="?query=tag:proxy" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#proxy</a> <a class="tag" href="?query=tag:Deployment" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Deployment</a> 
 <br><br>
<br>
open source orchestration system (컨테이너를 쉽고 빠르게 배포, 관리해주는 Tool)

<br>
<a data-href="K8s 기본구조_과거" href="excalidraw/k8s-기본구조_과거.html" class="internal-link" target="_self" rel="noopener">K8s 기본구조_과거</a><br>
→ 더이상 docker가 K8s 런타임이 아니게 됨. 여러 충돌 문제 등으로

<br>
현재는 containerd 가 사용되고 있음.<br>
<img alt="현재 기본 k8s 구조" src="https://lh6.googleusercontent.com/4NGAPzwhkL0GTNjkAEFN9iWX_Wc0ZE-AZxAxEw4E5aOntuGmv764b3ZYQUyapSnP9BrlUs2rUyo5kiCrj5QuiMHw3-dz2vPUDma029Qt3tej9QABEHFSsOBsq6LjLfFhTBgMhAAc" referrerpolicy="no-referrer">

<br>
개발자 kubectl -----&gt; Api server----&gt; worker node에 kubelet 명령 ---&gt; Pod 관리

<br>
kubelet(각 컨테이너의 실행을 보장하는 서비스) - 지정된 컨테이너를 실행하도록 Docker에 명령

<br><br>Master Node 🔑 컨테이너 선단을 지휘하는 통제함<br>
→ 주요 컨트롤 유닛으로서 Worker Nodes를 관리하는 주체<br>
<br>API Server - 쿠버네티스&nbsp;<a data-tooltip-position="top" aria-label="https://kubernetes.io/ko/docs/reference/glossary/?all=true#term-control-plane" rel="noopener" class="external-link" href="https://kubernetes.io/ko/docs/reference/glossary/?all=true#term-control-plane" target="_blank">컨트롤 플레인</a>의 핵심. 최종 사용자, 클러스터의 다른 부분 그리고 외부 컴포넌트가 서로 통신할 수 있도록 HTTP API를 제공한다.
<br>Scheduler - 스케줄링. pod를 적절한 worker node에 배포(할당)하는 component. <br> 즉, 새로운 컨테이너가 어느 노드에서 실행될 지 결정하는 component.
<br>Controller Manager (CM) - 컨트롤러 관리. node의 상태 모니터링(직접 하는 것은 아니고 API Server로부터 state 값을 전달받음), 로그 확인 가능

<br>Node Controller
<br>Replication Controller
<br>Deployment Controller


<br>ETCD - 설정 관리, 서비스 discovery, 스케줄링 등을 위한 데이터를 저장하는 저장소 역할 (key-value)
<br>Worker Node 🔑 파드가 배포 및 실행되는 노드. 파드를 생성하고 관리하는 실질적인 주체<br>
→ 할당된 task를 요청대로 수행하며, master node와 통신하는 시스템<br>
<br>kubelet - 각 노드에서 실행되는 일종의 agent. 
<br>kube-proxy - 각 노드에서 실행되는 네트워크 프록시.<br>
→ 지속적으로 service, pod의 변경 사항을 확인한다.<br>
→ worker node로 유입되는 트래픽을 적절한 pod로 라우팅한다.
<br>container runtime - pod에서 실행될 컨테이너 엔진. containerd
<br><br>
<br>컨테이너가 수가 증가할수록 그 환경이 복잡해진다.
<br>쿠버네티스는 컨테이너를 pod로 분류해서 이 문제를 해결한다.
<br><a data-href="Docker" href="docker-&amp;-k8s/docker.html" class="internal-link" target="_self" rel="noopener">Docker</a>는 단일 호스트에서 동작하는 컨테이너 실행 및 관리를 위한 도구라면 K8s는 여러 호스트 및 클러스터 환경에서 컨테이너화된 애플리케이션을 자동으로 배포하고 운영하는 데에 중점을 둔다는 점이 차이점이다. 이 둘은 각각의 강점을 가지고 있어, 적절한 상황에서 조합하여 사용하는 것이 일반적인 모던 컨테이너 기반 애플리케이션 개발 및 운영의 접근 방식이다.
<br><br>
<br>쿠버네티스 시스템에서 영속성을 가지는 Object
<br>포드(Pod), 레플리카셋(Replica Set), 서비스(<a data-href="Service" href="docker-&amp;-k8s/service.html" class="internal-link" target="_self" rel="noopener">Service</a>), 디플로이먼트(Deployment)
<br><br>
<br>container를 실행하기 위한 object
<br>K8s의 가장 기본이 되는 단위
<br>하나의 pod 안에 여러 개의 컨테이너가 들어갈 수 있다.
<br>동적으로 생성되고, 장애가 생기면 자동 restart되면서 IP가 변경됨.
<br><img alt="pod" src="https://i0.wp.com/bespin-wordpress-bucket.s3.ap-northeast-2.amazonaws.com/wp-content/uploads/2022/06/%EA%B7%B8%EB%A6%BC62.png?resize=378%2C301&amp;ssl=1" referrerpolicy="no-referrer"><br><br>
<br>요청 트래픽을 지정된 파드로 전송한다.
<br>서로 다른 Pod가 동일한 서버에 있든, 다른 서버에 위치하든 상관 없이 통신할 수 있게 한다.
<br><br>
<br>Container의 집합(Pods)를 관리하는 컨트롤러
<br>정해진 개수의 pod를 유지해주는 도구.
<br>이 replica set이 삭제 되지 않아 pod를 지워도 다시 살아나는 문제가 발생할 수 있다.
<br><br>
<br>🔑 K8s 객체 들을 격리해주는 공간
<br>쿠버네티스 클러스터( <a href=".?query=tag:Cluster" class="tag" target="_blank" rel="noopener">#Cluster</a>; 쿠버네티스가 구성된 환경) 내의 논리적인 분리 단위
<br>컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다.
<br><br>
<br>Pod를 포함한 각종 K8s Object를 관리하기 위한 = 태그와 유사하다.
<br><br>
<br>모든 Node 또는 특정 label을 가진 node에 하나씩의 동일한 pod를 배포해주는 resource
<br><br>
<br>Pod의 상태를 저장하고 관리하는 Resource
<br>Deployment와 거의 동일한 특성을 갖지만, 각 Pod의 순서와 고유성을 보장한다.
<br><br>
<br>들어오는 요청을 적절한 서비스로 전달해야 하는 역할
<br>L7
<br>url 기반 routing
<br><br>
<br><a data-tooltip-position="top" aria-label="https://rection34.tistory.com/137" rel="noopener" class="external-link" href="https://rection34.tistory.com/137" target="_blank">K8s Pod 구성 패턴</a> | <a data-tooltip-position="top" aria-label="https://waspro.tistory.com/775" rel="noopener" class="external-link" href="https://waspro.tistory.com/775" target="_blank">K8s Multi Container Design Pattern</a>
<br>Side Car pattern<br>
기본 컨테이너의 기능을 확장 or 보조하는 용도의 컨테이너를 추가하는 패턴<br>
ex) 로깅 목적의 컨테이너를 따로 side car로 추가한다.<br>
<img alt="300" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FccgdcF%2FbtrFT2YqujL%2FmiN0IvhlfJRNJKOKG01B0K%2Fimg.png" referrerpolicy="no-referrer">
<br>Ambassador pattern<br>
파드 안에서 <a href=".?query=tag:proxy" class="tag" target="_blank" rel="noopener">#proxy</a> 역할을 하는 컨테이너를 추가하는 패턴<br>
<img alt="300" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F72sMC%2FbtrFTOF7GrA%2FJGmTNSHx6qm7KsPd0kf191%2Fimg.png" referrerpolicy="no-referrer">
<br>Adapter pattern<br>
파드 외부로 노출되는 정보를 표준화하는 Adapter 컨테이너를 사용하는 패턴<br>
(adatper container를 통해 데이터를 변환)<br>
<img alt="300" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbNncKa%2FbtrFVULU9Bk%2F125IN14ld61lO0SsF9XR3k%2Fimg.png" referrerpolicy="no-referrer">
<br><br>
<br>HPA (Horizontal Pod Autoscaler)
<br>VPA (Vertical Pod Autoscaler)
<br>Cluster Autoscaler
<br>


<br>Fargate는 serverless 컴퓨팅 환경. K8s에서는 노드 관리가 필요하지만 Fargate에서는 필요 없음. 
<br>K8s에서는 노드 기반의 스케일링이 필요 VS Fargate에서는 컨테이너 기반의 스케일링만 필요


<br><br>
<br>Rolling update - 정해진 비율만큼의 파드만 점진적으로 배포<br>
최소한의 오버헤드와 다운타임
<br>Blue/Green - ver 1.0 과 ver 2.0 을 구성하고, 트래픽을 ver 2.0 쪽으로 전환하는 방식<br>
구 버전(Blue)과 동일한 환경에 신 버전(Green)의 배포를 전부 구축하고, LB를 수정하여 Green 을 한꺼번에 가리키게 한다.<br>
단점 - 잠시라도 신 버전을 완전히 새 환경에서 구축해야 되기에 일시적이라도 시스템 자원 2배 필요
<br>Canary - ver 2.0을 일부 배포하고, 트래픽도 일부만 ver 2.0으로 전환한다. 배포에 문제가 없다면 ver 2.0을 점진적으로 배포 및 트래픽을 전환한다.
<br><br>
<br>AWS - EKS (Amazon Elastic Kubernetes Service)
<br>Azure - AKS (Azure Kubernetes Service)
<br>GCP - <a data-href="GKE" href="docker-&amp;-k8s/gke.html" class="internal-link" target="_self" rel="noopener">GKE</a> (Google kubernetes Engine)
<br><br>
<br>Mini + kube
<br>쿠버네티스 클러스터 구축을 간단하게 할 수 있도록 만들어주기 위해서 시작된 프로젝트
<br><a data-href="ArgoCD" href="docker-&amp;-k8s/argocd.html" class="internal-link" target="_self" rel="noopener">ArgoCD</a>
<br><br>
<br>kubectl create ns namespace
<br>kubectl delete ns namespace
<br>kubectl get po pod
<br>kubectl delete po pod
<br>kubectl edit po pod
<br>kubectl describe deploy deployment
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://kubernetes.io/ko/docs/concepts/overview/" rel="noopener" class="external-link" href="https://kubernetes.io/ko/docs/concepts/overview/" target="_blank">쿠버네티스란 무엇인가-공식docs</a>
<br><a data-tooltip-position="top" aria-label="https://coffeewhale.com/k8s/network/2019/04/19/k8s-network-01/" rel="noopener" class="external-link" href="https://coffeewhale.com/k8s/network/2019/04/19/k8s-network-01/" target="_blank">쿠버네티스 네트워킹 이해하기#1: Pods</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=JNc11rxLtmE" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=JNc11rxLtmE" target="_blank">클라우드 시장의 대세, 쿠버네티스란 무엇인가?</a>
<br><a data-tooltip-position="top" aria-label="https://www.yes24.com/Product/Goods/108431011" rel="noopener" class="external-link" href="https://www.yes24.com/Product/Goods/108431011" target="_blank">책-그림과 실습으로 배우는 도커 &amp; 쿠버네티스</a>
<br><a data-href="15단계로 배우는 도커와 쿠버네티스" href="books/15단계로-배우는-도커와-쿠버네티스.html" class="internal-link" target="_self" rel="noopener">15단계로 배우는 도커와 쿠버네티스</a>
<br><a data-tooltip-position="top" aria-label="https://essem-dev.medium.com/%EC%98%88%EC%A0%9C%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-4b9751b23962" rel="noopener" class="external-link" href="https://essem-dev.medium.com/%EC%98%88%EC%A0%9C%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-4b9751b23962" target="_blank">예제로 배우는 쿠버네티스</a>
<br><a data-tooltip-position="top" aria-label="https://blog.devops.dev/end-to-end-devsecops-kubernetes-project-4259f90722ef" rel="noopener" class="external-link" href="https://blog.devops.dev/end-to-end-devsecops-kubernetes-project-4259f90722ef" target="_blank">End to end devops</a>
<br><a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/41509439/whats-the-difference-between-clusterip-nodeport-and-loadbalancer-service-types" rel="noopener" class="external-link" href="https://stackoverflow.com/questions/41509439/whats-the-difference-between-clusterip-nodeport-and-loadbalancer-service-types" target="_blank">Service Type Comparison</a>
]]></description><link>docker-&amp;-k8s/kubernetes.html</link><guid isPermaLink="false">Docker &amp; K8s/Kubernetes.md</guid><pubDate>Fri, 02 Feb 2024 02:02:13 GMT</pubDate><enclosure url="https://lh6.googleusercontent.com/4NGAPzwhkL0GTNjkAEFN9iWX_Wc0ZE-AZxAxEw4E5aOntuGmv764b3ZYQUyapSnP9BrlUs2rUyo5kiCrj5QuiMHw3-dz2vPUDma029Qt3tej9QABEHFSsOBsq6LjLfFhTBgMhAAc" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://lh6.googleusercontent.com/4NGAPzwhkL0GTNjkAEFN9iWX_Wc0ZE-AZxAxEw4E5aOntuGmv764b3ZYQUyapSnP9BrlUs2rUyo5kiCrj5QuiMHw3-dz2vPUDma029Qt3tej9QABEHFSsOBsq6LjLfFhTBgMhAAc"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[단일 클러스터 내에서 리소스 그룹 격리 메커니즘을 제공한다.]]></title><description><![CDATA[ 
 <br><br>초기 네임 스페이스<br>
<br>default (기본)
<br>kube-node-lease (kubelet이 하트비트를 보내서 컨트롤 플레인이 노드의 장애 탐지할 수 있도록 함.)
<br>kube-public (모든 클라이언트가 읽기 권한으로 접근 가능)
<br>kube-system (쿠버네티스 시스템에서 생성한 object를 위한 네임스페이스)
<br>Not to do !<br>
<br>prefix with kube-  (쿠버네티스 시스템용으로 예약되어 있음.)
<br>kubectl<br>
<br>kubectl get namespace<br>
사용 중인 클러스터의 현재 네임스페이스를 나열
<br><br><br><br><br><a data-tooltip-position="top" aria-label="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/namespaces" rel="noopener" class="external-link" href="https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/namespaces" target="_blank">네임스페이스</a>]]></description><link>docker-&amp;-k8s/namespace.html</link><guid isPermaLink="false">Docker &amp; K8s/Namespace.md</guid><pubDate>Tue, 16 Jan 2024 07:28:10 GMT</pubDate></item><item><title><![CDATA[PV & PVC]]></title><description><![CDATA[ 
 <br><img src="https://blog.kakaocdn.net/dn/b17MGq/btrrP4ojece/PxHCyMhiiak9IyRjQ44Gk0/img.png" referrerpolicy="no-referrer"><br>Kubernetes Storage<br>쿠버네티스에서 볼륨(Volume)을 사용하는 구조는 PV라고 하는 퍼시스턴트 볼륨(PersistentVolume)과 PVC라고 하는 퍼시스턴트 볼륨 클레임(PersistentVolumeClaim) 2개로 분리되어 있습니다.<br><br>PV는 볼륨 자체를 뜻합니다. 클러스터 안에서 자원으로 다룹니다. 파드와는 별개로 관리되며 별도의 생명 주기가 있습니다.&nbsp;PVC는 사용자가 PV에 하는 요청입니다. 사용하고 싶은 용량은 얼마인지, 읽기/쓰기는 어떤 모드로 설정하고 싶은지 등을 정해서 요청합니다.<br>쿠버네티스 볼륨을 파드에 직접 할당하는 방식이 아니라 중간에 PVC를 두어 파드와 파드가 사용할 스토리지를 분리했습니다. 이런 구조는 파드 각각의 상황에 맞게 다양한 스토리지를 사용할 수 있게 합니다.&nbsp;<br>클라우드 서비스를 사용할 때는 본인이 사용하는 클라우드 서비스에서 제공해주는 볼륨 서비스를 사용할 수도 있고, 직접 구축한 스토리지를 사용할 수도 있습니다. 이렇게 다양한 스토리지를 PV로 사용할 수 있지만 파드에 직접 연결하는 것이 아니라 PVC를 거쳐서 사용하므로 파드는 어떤 스토리지를 사용하는지 신경 쓰지 않아도 됩니다.<br>PV와 PVC는 다음과 같은 생명주기가 있습니다.<br><img src="https://blog.kakaocdn.net/dn/cGG4N9/btrrKIfEPPV/chFy6chDn2PC23MbvC13t1/img.png" referrerpolicy="no-referrer"><br>PV/PVC의 생명 주기<br><br>PV를 만드는 단계를 프로비저닝(Provisioning)이라고 합니다. 프로비저닝 방법에는 두 가지가 있는데, PV를 미리 만들어 두고 사용하는 정적(static) 방법과 요청이 있을 때 마다 PV를 만드는 동적(dynamic) 방법입니다.<br><br>정적으로 PV를 프로비저닝할 때는 클러스터 관리자가 미리 적정 용량의 PV를 만들어 두고 사용자의 요청이 있으면 미리 만들어둔 PV를 할당합니다. 사용할 수 있는 스토리지 용량에 제한이 있을 때 유용합니다.&nbsp;사용하도록 미리 만들어 둔 PV의 용량이 100GB라면 150GB를 사용하려는 요청들은 실패합니다. 1TB 스토리지를 사용하더라도 미리 만들어 둔 PV 용량이 150GB 이상인 것이 없으면 요청이 실패합니다.<br><br>동적으로 프로비저닝 할 때는 사용자가 PVC를 거쳐서 PV를 요청했을 때 생성해 제공합니다. 쿠버네티스 클러스터에 사용할 1TB 스토리지가 있다면 사용자가 원하는 용량만큼을 생성해서 사용할 수 있습니다. 정적 프로비저닝과 달리 필요하다면 한번에 200GB PV도 만들 수 있습니다. PVC는 동적 프로비저닝할 때 여러가지 스토리지 중 원하는 스토리지를 정의하는 스토리지 클래스(Storage Class)로 PV를 생성합니다.<br><br>바인딩(Binding)은 프로비저닝으로 만든 PV를 PVC와 연결하는 단계입니다. PVC에서 원하는 스토리지의 용량과 접근방법을 명시해서 요청하면 거기에 맞는 PV가 할당 됩니다. 이 때 PVC에서 원하는 PV가 없다면 요청은 실패합니다. 하지만 PVC는 원하는 PV가 생길 때까지 대기하다가 바인딩합니다.&nbsp;<br>PV와 PVC의 매핑은 1대1 관계 입니다. PVC 하나가 여러 개 PV에 할당될 수 없습니다.<br><br>PVC는 파드에 설정되고 파드는 PVC를 볼륨으로 인식해서 사용합니다.<br>할당된 PVC는 파드를 유지하는 동안 계속 사용하며 시스템에서 임의로 삭제할 수 없습니다. 이 기능을 'Storage Object in Use Protection' (사용 중인 스토리지 오브젝트 보호)라고 합니다. 사용 중인 데이터 스토리지를 임의로 삭제하는 경우 치명적인 결과가 발생할 수 있으므로 이런 보호 기능을 사용하는 것입니다.<br><br>사용이 끝난 PVC는 삭제되고 PVC를 사용하던 PV를 초기화(reclaim)하는 과정을 거칩니다. 이를 Reclaiming(반환)이라고 합니다.&nbsp;<br>초기화 정책에는 Retain, Delete, Recycle이 있습니다.<br><br>Retain은 PV를 그대로 보존합니다. PVC가 삭제되면 사용 중이던 PV는 해제(released) 상태여서 다른 PVC가 재사용할 수 없습니다. 단순히 사용 해제 상태이므로 PV 안의 데이터는 그대로 남아있습니다. 이 PV를 재사용하려면 관리자가 다음 순서대로 직접 초기화해줘야합니다.<br>
<br>PV 삭제. 만약 PV가 외부 스토리지와 연결되었다면 PV는 삭제되더라도 외부 스토리지의 볼륨은 그대로 남아 있습니다.
<br>스토리지에 남은 데이터를 직접 정리
<br>남은 스토리지의 볼륨을 삭제하거나 재사용하려면 해당 볼륨을 이용하는 PV 재생성
<br><br>PV를 삭제하고 연결된 외부 스토리지 쪽의 볼륨도 삭제합니다. 프로비저닝할 때 동적 볼륨 할당 정책으로 생성된 PV들은 기본 반환 정책(Reclaim Policy)이 Delete 입니다. 상황에 따라 처음에 Delete로 설정된 PV의 반환 정책을 수정해서 사용해야 합니다.<br><br>Recycle은 PV의 데이터들을 삭제하고 다시 새로운 PVC에서 PV를 사용할 수 있도록 합니다. 특별한 파드를 만들어 두고 데이터를 초기화하는 기능도 있지만 동적 볼륨 할당을 기본 사용할 것을 추천<br><br><br><br>8번 라인의 .spec.volumeMode 필드는 쿠버네티스 1.9버전 부터 추가된 필드입니다. 기본 필드 값은 FileSystem 으로 볼륨을 파일 시스템 형식으로 사용합니다. 추가로 raw 라는 필드 값을 설정할 수 있습니다. 볼륨을&nbsp; RAW 블록 디바이스 형식으로 설정해서 사용합니다. RAW 블록 디바이스를 지원하는 스토리지 플로그인은 awsElasticBlockStore, azureDisc, fc(fibre channel), gcePersistentDisk, iscsi, local volume, Ceph Block Device의 rbd 등이 있습니다.<br>9번 라인의 .spec.accessModes 필드는 볼륨의 읽기/쓰기 옵션을 설정합니다. 볼륨은 한 번에&nbsp; accessModes 필드를 하나만 설정할 수 있으며 필드 값은 세 가지가 있습니다.&nbsp;<br>
<br>ReadWriteOnce: 노드 하나에만 볼륨을 읽기/쓰기하도록 마운트할 수 있음
<br>ReadOnlyMany: 여러 개 노드에서 읽기 전용으로 마운트할 수 있음
<br>ReadWriteMany: 여러 개 노드에서 읽기/쓰기 가능하도록 마운트할 수 있음
<br>11번 라인의 .spec.storageClassName 은 스토리지 클래스(StorageClass)를 설정하는 필드입니다. 특정 스토리지 클래스가 있는 PV는 해당 스토리지 클래스에 맞는 PVC만 연결됩니다. PV에 &nbsp;.spec.storageClassName 필드 설정이 없으면 &nbsp;.spec.storageClassName 필드 설정이 없는 PVC와만 연결됩니다.<br>12번 라인의 .spec.persistentVolumeReclaimPolicy 필드는 PV가 해제되었을 때 초기화 옵션을 설정합니다. 앞에서 살펴본 것 처럼 Retain, Recycle, Delete 정책 중 하나입니다.<br>14번 라인의 .spec.hostPath 필드는 해당 PV의 볼륨 플러그인을 명시합니다. 필드 값을 hostPath로 설정했기 때문에 하위의 .spec.hostPath.path 필드는 마운트시킬 로컬 서버의 경로를 설정합니다.<br>위의 설정을 pv-hostpath.yaml 로 저장하고 kubectl apply -f pv-hostpath.yaml 명령으로 클러스터에 적용합니다.<br>
그 후 kubectl get pv 명령어로 PV의 상태를 확인합니다.<br><br>STATUS 항목이 Available이면 정상적으로 설정된 것입니다. PV의 STATUS 값은 PVC에서 사용할 수 있도록 준비된 Available, 특정 PVC에 연결된 Bound, PVC는 삭제되었고 PV는 아직 초기화 되지 않은 Released, 자동 초기화를 실패한 Failed 등이 있습니다.<br><br><br>주요 필드는 PV에서 설정한 필드와 유사합니다.<br>9~11번 라인의 .spec.resources.requests.storage 필드는 자원을 얼마나 사용할 것인지 요청(request)합니다. 여기서는 필드 값으로 1Gi(1GB)를 설정했습니다. 필드 값을 설정할 때는 앞에서 만든 PV의 용량을 초과하면 안됩니다. 만약 초과하는 경우 사용할 수 있는 PV가 없으므로 PVC를 생성할 수 없는 Pending 상태가 됩니다.<br>또한&nbsp; .spec.storageClassName 필드를 위에서 생성한 PV와 동일하게 생성하여 위의 PV에 정상적으로 연결될 수 있도록 합니다.<br>위의 설정을&nbsp;pvc-hostpath.yaml&nbsp;로 저장하고&nbsp;kubectl apply -f pvc-hostpath.yaml&nbsp;명령으로 클러스터에 적용합니다.<br>
그 후&nbsp;kubectl get pvc 와 kubectl get pv 명령어로 PVC와 PV 상태를 확인합니다.<br><br>7번 라인의 STATUS 항목은 Bound이고 VOLUME 항목은 pv-hostpath 입니다. 이전에 생성한 PV인 pv-hostpath에 연결되었다는 의미입니다.<br>또한 11번 라인에서 PV 또한 STATUS가 Bound로 바뀐 것을 확인할 수 있습니다.]]></description><link>docker-&amp;-k8s/pv-&amp;-pvc.html</link><guid isPermaLink="false">Docker &amp; K8s/PV &amp; PVC.md</guid><pubDate>Thu, 25 Jan 2024 01:57:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/b17MGq/btrrP4ojece/PxHCyMhiiak9IyRjQ44Gk0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/b17MGq/btrrP4ojece/PxHCyMhiiak9IyRjQ44Gk0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Secret]]></title><description><![CDATA[ 
 <br>
<br>--dry-run -o yaml<br>
: 결과를 클러스터에 바로 반영하는 게 아니라 어떤 결과를 만들어낼지를 일단 확인해보기 위함.
]]></description><link>docker-&amp;-k8s/secret.html</link><guid isPermaLink="false">Docker &amp; K8s/Secret.md</guid><pubDate>Mon, 29 Jan 2024 07:01:55 GMT</pubDate></item><item><title><![CDATA[Pod 집합에서 실행 중인 애플리케이션을 network 서비스로 노출하는 추상화 방법]]></title><description><![CDATA[<a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> 
 <br><a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> <br><br><br>서비스를 클러스터 밖에 위치한 외부 IP 주소에 노출하고 싶을 때.<br>
Nested 기능으로 설계되어, 각 단계는 이전 단계에 더해지는 형태이다.<br>
<br>Cluster IP 

<br>서비스를 클러스터-내부 IP에 노출
<br>타입을 지정하지 않으면 기본으로 설정
<br>클러스터 내부의 파드에서 서비스의 이름을 접근


<br>Node Port 

<br>고정 포트 NodePort로 각 노드의 IP에 서비스를 노출
<br>Cluster IP의 접근 범위 뿐만 아니라 K8s 클러스터 외부에서도 노드의 IP 주소와 포트번호로 접근


<br>Load Balancer

<br>로드 밸런서를 사용하여 서비스를 외부에 노출
<br>Node Port의 접근 범위 뿐만 아니라 K8s 클러스터 외부에서 대표 IP 주소로 접근


<br>External Name

<br>K8s 클러스터 내부 파드에서 외부 IP 주소에 서비스의 이름으로 접근


]]></description><link>docker-&amp;-k8s/service.html</link><guid isPermaLink="false">Docker &amp; K8s/Service.md</guid><pubDate>Tue, 16 Jan 2024 07:34:21 GMT</pubDate></item><item><title><![CDATA[Pulumi]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://www.ciokorea.com/news/235799?page=0,1" rel="noopener" class="external-link" href="https://www.ciokorea.com/news/235799?page=0,1" target="_blank">Why pulumi?</a><br>
<br>기존 IaC의 복잡성 (클라우드포메이션 및 테라폼과 같은 기존 코드형 인프라 옵션은 지나치게 복잡하다.)
<br>→ 마이크로소프트 애저를 위한 바이셉(Bicep), 또는 쿠버네티스를 위한 YAML과 같은 독점적 기술이 아닌 자신이 선호하는 프로그래밍 언어로 인프라 구성 작업을 할 수 있도록 하는 데 목표를 둔다. ]]></description><link>iac/pulumi.html</link><guid isPermaLink="false">IaC/Pulumi.md</guid><pubDate>Thu, 04 Jan 2024 08:18:48 GMT</pubDate></item><item><title><![CDATA[Terraform]]></title><description><![CDATA[<a class="tag" href="?query=tag:terraform" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#terraform</a> 
 <br><a href=".?query=tag:terraform" class="tag" target="_blank" rel="noopener">#terraform</a><br><a data-tooltip-position="top" aria-label="https://registry.terraform.io/search/providers?namespace=hashicorp" rel="noopener" class="external-link" href="https://registry.terraform.io/search/providers?namespace=hashicorp" target="_blank">Providers</a>]]></description><link>iac/terraform.html</link><guid isPermaLink="false">IaC/Terraform.md</guid><pubDate>Wed, 07 Feb 2024 00:13:14 GMT</pubDate></item><item><title><![CDATA[Deploy Actions Runner Controller (ARC) using ArgoCD]]></title><description><![CDATA[<a class="tag" href="?query=tag:Github_Actions" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Github_Actions</a> <a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> <a class="tag" href="?query=tag:ARC" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ARC</a> 
 <br><a href=".?query=tag:Github_Actions" class="tag" target="_blank" rel="noopener">#Github_Actions</a> <a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a><br>
updated at 2024-03-18<br><br><br>
<br>vm처럼 단일 instance에 Github Actions runner를 설치할 수도 있지만, <a href=".?query=tag:ARC" class="tag" target="_blank" rel="noopener">#ARC</a> 를 사용해 K8s 위에 설치할 수 있다. (= 쿠버네티스 파드로 러너 실행 가능.)

<br>장점 : 비용 효율성 &amp; 확장성 &amp; 속도


<br>
<br>App Repository &gt; workflow 생성 
git clone `repository url`
cd 해당 repository 경로
mkdir -p .github/workflows
cd .github/workflows
vi github-actions-demo.yml
Copy

<br><br>
<br>A Kubernetes cluster for hosting ARC and ArgoCD
<br>kubectl configured to manage the above cluster
<br>Helm CLI
<br>kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
Copy<br>openssl req -x509 -nodes -days 365 -newkey rsa:4096 -keyout private.key -out certificate.crt -subj "/CN=sealed-secrets/O=my-org"
Copy<br>kubectl create secret tls sealed-secrets-key --key=private.key --cert=certificate.crt -n kube-system 
helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets  \
helm install sealed-secrets sealed-secrets/sealed-secrets -n kube-system --set secretName=sealed-secrets-key --atomic
Copy<br>curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64  
sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd  
rm argocd-linux-amd64
Copy<br>kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'
Copy<br>external IP로 접속 (34.28.176.180)<br>ADMIN_PASSWORD=$(argocd admin initial-password -n argocd | head -n 1)
echo $ADMIN_PASSWORD
Copy<br>9kx6wCP8pOsbTaa8<br>argocd login 34.28.176.180 --insecure  --username "admin" --password "${ADMIN_PASSWORD}"
Copy<br>argocd app create actions-runner-controller-apps \
    --dest-namespace argocd \
    --dest-server https://kubernetes.default.svc \
    --repo https://github.com/step-security/code-samples.git \
    --path deploy-arc-using-argocd/github-supported/controller \
    --sync-policy automated --auto-prune --self-heal
Copy<br><br>
<br><a data-tooltip-position="top" aria-label="https://tech.buzzvil.com/blog/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EA%B2%8C-github-actions-%EC%84%A4%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%B4-%EB%AC%BB%EB%8B%A4/" rel="noopener" class="external-link" href="https://tech.buzzvil.com/blog/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EC%97%90%EA%B2%8C-github-actions-%EC%84%A4%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%B4-%EB%AC%BB%EB%8B%A4/" target="_blank">Github Actions by ARC</a>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@alli-eunbi/Git-EKS-ARC-%EC%84%B8%ED%8C%85-%EB%B0%A9%EB%B2%95" rel="noopener" class="external-link" href="https://velog.io/@alli-eunbi/Git-EKS-ARC-%EC%84%B8%ED%8C%85-%EB%B0%A9%EB%B2%95" target="_blank">https://velog.io/@alli-eunbi/Git-EKS-ARC-세팅-방법</a>
<br><a rel="noopener" class="external-link" href="https://ykarma1996.tistory.com/195" target="_blank">https://ykarma1996.tistory.com/195</a>
<br><a rel="noopener" class="external-link" href="https://trunk.io/blog/how-to-self-host-github-actions-runners" target="_blank">https://trunk.io/blog/how-to-self-host-github-actions-runners</a>
<br><a data-tooltip-position="top" aria-label="https://www.stepsecurity.io/blog/deploy-actions-runner-controller-using-argocd" rel="noopener" class="external-link" href="https://www.stepsecurity.io/blog/deploy-actions-runner-controller-using-argocd" target="_blank">Deploy Actions Runner Controller (ARC) using ArgoCD</a>
]]></description><link>arc.html</link><guid isPermaLink="false">ARC.md</guid><pubDate>Mon, 18 Mar 2024 02:11:11 GMT</pubDate></item><item><title><![CDATA[ARC with ArgoCD]]></title><description><![CDATA[ 
 <br><br>Owned by:&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/hnyeom" rel="noopener" class="external-link" href="https://github.com/hnyeom" target="_blank">@hnyeom</a><br>
App ID:&nbsp;819851<br>
Client ID:&nbsp;Iv1.318404186a5de9ec<br>
INSTALLATION_ID : 47016647<br>APP_ID=819851<br>
INSTALLATION_ID=47016647<br>
PRIVATE_KEY_FILE_PATH=<br>
kubectl create secret generic controller-manager <br>
-n actions-runner-system <br>
--from-literal=github_app_id={INSTALLATION_ID} <br>
--from-file=github_app_private_key=${PRIVATE_KEY_FILE_PATH}<br>mkdir arc &amp;&amp; cd arc<br><br>Install cert manager<br>
(<a rel="noopener" class="external-link" href="https://cert-manager.io/docs/installation/helm/" target="_blank">https://cert-manager.io/docs/installation/helm/</a>)<br>kubectl apply -f <a rel="noopener" class="external-link" href="https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.yaml" target="_blank">https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.yaml</a><br>helm repo add actions-runner-controller <a rel="noopener" class="external-link" href="https://actions-runner-controller.github.io/actions-runner-controller" target="_blank">https://actions-runner-controller.github.io/actions-runner-controller</a><br>
helm upgrade --install --namespace actions-runner-system --create-namespace <br>
--wait actions-runner-controller actions-runner-controller/actions-runner-controller<br>확인<br>
helm repo list<br>
helm list -A<br><br>
<br>(default) / install cert manager
<br>install ARC by Kubectl
<br>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.yaml

kubectl create -f https://github.com/actions/actions-runner-controller/releases/download/v0.25.2/actions-runner-controller.yaml
Copy<br><br><br>runnerdeployment.yaml<br>apiVersion: actions.summerwind.dev/v1alpha1
kind: RunnerDeployment
metadata:
  name: example-runnerdeploy
spec:
  # This will deploy 2 runners now
  replicas: 2
  template:
    spec:
      repository: everchloe97/argocd-example-apps
Copy<br>*note:- Replace “mumoshu/actions-runner-controller-ci” with your repository name.<br>kubectl apply -f runnerdeployment.yaml<br>helm upgrade --install --namespace actions-runner-system <br>
--create-namespace --wait actions-runner-controller <br>
actions-runner-controller/actions-runner-controller -f values.yaml<br>./run.sh --check --url https://github.com/everchloe97/argocd-example-apps --pat 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
Copy<br>kubectl get pod -n actions-runner | grep -i "k8s-action-runner"<br>kubectl create secret generic controller-manager -n actions-runner-system --from-literal=github_token=$GITHUB_TOKEN<br><a rel="noopener" class="external-link" href="https://medium.com/mossfinance/github-self-hosted-runners-on-kubernetes-with-actions-runner-controller-41e30c4cb76e" target="_blank">https://medium.com/mossfinance/github-self-hosted-runners-on-kubernetes-with-actions-runner-controller-41e30c4cb76e</a><br>&gt; mkdir actions-runner &amp;&amp; cd actions-runner
&gt; curl -O -L https://github.com/actions/runner/releases/download/v2.312.0/actions-runner-linux-x64-2.312.2.tar.gz
&gt; tar xzf ./actions-runner-linux-x64-2.312.2.tar.gz


Copy]]></description><link>arc-with-argocd.html</link><guid isPermaLink="false">ARC with ArgoCD.md</guid><pubDate>Wed, 07 Feb 2024 03:02:33 GMT</pubDate></item><item><title><![CDATA[AWS를 활용한 시스템 아키텍처 설계]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://www.wanted.co.kr/events/pre_challenge_be_17" rel="noopener" class="external-link" href="https://www.wanted.co.kr/events/pre_challenge_be_17" target="_blank">프리온보딩 백엔드 챌린지 3월</a><br><br>도커(docker)에 대해 설명해주세요<br>
<br>Your answer - 도커는 application source code, dependency, library 등을 압축하여 컨테이너화한 플랫폼입니다. 
<br>GPT's - 도커는 컨테이너 기술 기반의 오픈 소스 플랫폼으로, application을 가상화된 환경인 컨테이너에 패키징하여 실행할 수 있게 해주는 기술입니다. 각 컨테이너는 Application과 이에 필요한 Dependency를 포함하며 호스트 시스템과는 독립적으로 동작합니다.
<br>도커(docker)를 활용하면 어떤 장점이 있나요?<br>
<br>Your answer - 어떤 환경이든 동일하게 실행할 수 있다는 장점이 있고, Guest OS layer가 없기 때문에 VM을 사용했을 때보다 가볍고, overhead가 적습니다. 
<br>GPT's - 도커 컨테이너는 어디서든 동일한 환경에서 실행될 수 있고, 가볍고, (컨테이너는 빠르게 시작되고 중지될 수 있기에) 배포 및 확장성이 뛰어납니다. (환경의 일관성 &amp; 가벼움 &amp; 빠른 배포 및 확장 용이성)
<br>서버리스(serverless)에 대해 설명해주세요<br>
Your answer - ~~서버리스란 실제로 물리적 서버가 없다는 것을 의미하지는 않습니다. 다만 서버를 직접 물리적으로 설치하지 않는다는 것을 의미합니다. ~~<br>
틀리게 알고 있었네.<br>
<br>GPT's - 애플리케이션 개발 및 운영을 서버에서 직접하지 않고, 함수와 이벤트 중심의 컴퓨팅을 제공하는 것을 뜻합니다. 작성한 코드를 특정 이벤트에 바인딩하여 CSP가 이벤트가 발생될 때마다 필요한 컴퓨팅 리소스를 동적으로 할당하고 실행합니다.
<br>ex) AWS Lambda, Dynamo DB, AKS, Azure Functions
<br>서버리스(serverless)를 활용하면 어떤 장점이 있나요?<br>
<br>GPT's - on-demand 방식이므로 비용 절감을 할 수 있고, auto-scaling이 적용되면 트래픽 변동에도 대응하기 쉽습니다. 또 서버 관리를 CSP에 위임하므로 인프라 운영 및 관리에 대한 부담이 줄어듭니다.
<br>서비스를 배포한 경험에 대해 자유롭게 작성해주세요<br>
<br>Your answer - Azure container app &amp; AWS ECS 사용해서 실 서비스를 배포한 적이 있습니다.
<br>AWS를 비롯한 클라우드 서비스의 장점은 무엇인가요?<br>
<br>GPT's - 사용한 만큼만 요금을 지불하는 방식인 on-demand 방식을 사용하면 비용 절감에도 도움이 될 수 있고 많은 자동화된 서비스와 편리한 관리도구를 제공합니다. ex) DB, Storage, ML, Security, Data Back up etc... 그렇게 된다면 리소스 구축 뿐 아니라 관리도 용이해집니다. 
<br><br><br><br>AWS EC2, AWS RDS, AWS ElasticCache, AWS ALB, AWS CloudFront, AWS DynamoDB, AWS Lambda  <br>
<br>RDS를 활용한 데이터베이스 scaling  
<br>ALB + EC2를 활용한 서버 scaling  
<br>Serverless 활용 시 장단점
<br>보통 시작은 RDB, 데이터 규모가 크면 NoSQL을 쓴다. ex) 네카라쿠배<br>
RDB쓰면 천만 row만 되어도 full scan 때리면 15분 이상 걸리기도 한다.<br>
index도 잘 걸어야 하고, 데이터 양이 많아지고 join 테이블 조회할 양이 많아지면 확실히 속도가 느리다.<br>
그래서 현업에서는 read에 NoSQL을 쓰고 write에 RDB를 쓰는 경우가 종종 있다.<br>instagram에서 쓰는 카산드라 DB. multi-write가 가능하다. write를 분산시켜서 단일 write server가 죽는 걸 대비한다.<br><br><br><br>AWS SQS, AWS SNS, AWS Neptune, AWS Aurora, AWS ElasticCache, AWS CloudFront  <br>
<br>Message Queue를 활용한 느슨한 결합이란? <a data-href="Kafka" href="kafka.html" class="internal-link" target="_self" rel="noopener">Kafka</a>
<br>서비스 운영 방식에 맞는 데이터 스키마 설계와 데이터베이스 선택  
<br>올바른 ElasticCache 활용법
<br><br><br>Polling이 필요한 http 통신 VS web socket 통신<br><br>추천 영상은 cache 되어 있을 가능성이 높다.<br>transcoding : 원본 영상을 업로드 → 화질별로 나눠서 저장<br>
Lambda는 15분 timeout이 존재하므로, SQS나 SNS를 추천한다.<br>DAG : <a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank">https://en.wikipedia.org/wiki/Directed_acyclic_graph</a><br>pre-signed url<br>
<br>client에서 s3로 바로 업로드
<br>server에 부하가 없으므로 대규모 서비스에서 사용할 때 합리적, 일반적으로 많이 사용됨.
]]></description><link>aws를-활용한-시스템-아키텍처-설계.html</link><guid isPermaLink="false">AWS를 활용한 시스템 아키텍처 설계.md</guid><pubDate>Wed, 13 Mar 2024 12:10:03 GMT</pubDate></item><item><title><![CDATA[Azure DMS]]></title><description><![CDATA[ 
 <br>terraform azurerm version 3.93.0 에서는 옵션이 제한적이어서 설정 불가.<br>마이그레이션 유형<br>
<br>온라인 마이그레이션은 소스 데이터베이스가 마이그레이션하는 동안 계속 사용 가능

<br>sku = premium 에서만 지원


<br>오프라인 마이그레이션은 마이그레이션 동안 데이터베이스 접근이 중단됩니다.
<br>// replica와 원본 값이 다름<br>
call mysql.rds_set_configuration('binlog retention hours', 24);]]></description><link>azure-dms.html</link><guid isPermaLink="false">Azure DMS.md</guid><pubDate>Fri, 23 Feb 2024 08:41:37 GMT</pubDate></item><item><title><![CDATA[Blob(Binary Large Object, 블랍)]]></title><description><![CDATA[ 
 ]]></description><link>blob(binary-large-object,-블랍).html</link><guid isPermaLink="false">Blob(Binary Large Object, 블랍).md</guid><pubDate>Wed, 07 Feb 2024 07:41:50 GMT</pubDate></item><item><title><![CDATA[CICD Tools]]></title><description><![CDATA[ 
 <br><br>Github Actions vs Jenkins 실행 속도<br>이 두 도구의 성능은 서버의 성능과 환경에 따라 달라진다고 이해하는 게 더 맞는 것으로 보입니다.<br>
Github Actions의 runner가 self-hosted 환경인 경우(사용자가 직접 서버를 설치해서 사용하는 경우)도 그렇고 Jenkins도 서버의 사양, JVM 설정 등에 따라 그 실행 속도에 차이가 있기 때문입니다.<br>
(Github Actions의 runner가 github에서 제공하는 <a data-tooltip-position="top" aria-label="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners" rel="noopener" class="external-link" href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners" target="_blank">github-hosted-runner</a>인 경우에는 다를 수 있습니다.)]]></description><link>cicd-tools.html</link><guid isPermaLink="false">CICD Tools.md</guid><pubDate>Tue, 06 Feb 2024 00:29:46 GMT</pubDate></item><item><title><![CDATA[Coroutine]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://dev.gmarket.com/82" rel="noopener" class="external-link" href="https://dev.gmarket.com/82" target="_blank">Coroutine</a> (Co + Routine)<br>
<br>비동기적으로 실행되는 코드를 간소화하기 위한 패턴. 
<br>코드 양 감소. 
<br>스레드 제어를 직접한다.
]]></description><link>coroutine.html</link><guid isPermaLink="false">Coroutine.md</guid><pubDate>Tue, 16 Jan 2024 02:19:33 GMT</pubDate></item><item><title><![CDATA[데비안 (Debian GNU/Linux)]]></title><description><![CDATA[ 
 <br><br>
<br>데비안은 전 세계에서 가장 많이 서버로 이용되는 OS였으나 2016년 이후로&nbsp;<a data-tooltip-position="top" aria-label="https://namu.wiki/w/%EC%9A%B0%EB%B6%84%ED%88%AC" rel="noopener" class="external-link" title="우분투" href="https://namu.wiki/w/%EC%9A%B0%EB%B6%84%ED%88%AC" target="_blank">우분투</a>서버에게 그 자리를 내주었다.
<br>데비안은 프로그램들을 deb란 패키지로 묶어서 관리
]]></description><link>debian.html</link><guid isPermaLink="false">Debian.md</guid><pubDate>Tue, 09 Jan 2024 02:13:41 GMT</pubDate></item><item><title><![CDATA[Error]]></title><description><![CDATA[ 
 <br><br>
<br>
<a data-tooltip-position="top" aria-label="https://reallinux.co.kr/blog/199" rel="noopener" class="external-link" href="https://reallinux.co.kr/blog/199" target="_blank">Address already in use (Bind failed) 문제 해결방법</a>

<br>
<a data-tooltip-position="top" aria-label="https://ccambo.tistory.com/entry/Kubernetes-Troubleshooting-%EC%82%AD%EC%A0%9C%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-Namespace-%EA%B0%95%EC%A0%9C%EB%A1%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0" rel="noopener" class="external-link" href="https://ccambo.tistory.com/entry/Kubernetes-Troubleshooting-%EC%82%AD%EC%A0%9C%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-Namespace-%EA%B0%95%EC%A0%9C%EB%A1%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0" target="_blank">kubectl delete ns 안됨</a><a data-tooltip-position="top" aria-label="https://crois.net/k8s-namespace-%EA%B0%95%EC%A0%9C-%EC%82%AD%EC%A0%9C/" rel="noopener" class="external-link" href="https://crois.net/k8s-namespace-%EA%B0%95%EC%A0%9C-%EC%82%AD%EC%A0%9C/" target="_blank">해결</a>

]]></description><link>error.html</link><guid isPermaLink="false">Error.md</guid><pubDate>Fri, 02 Feb 2024 05:56:46 GMT</pubDate></item><item><title><![CDATA[구글에서 개발한 클라우드 컴퓨팅 플랫폼.]]></title><description><![CDATA[<a class="tag" href="?query=tag:kubernetes" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#kubernetes</a> 
 <br><br>
<br><a href=".?query=tag:kubernetes" class="tag" target="_blank" rel="noopener">#kubernetes</a> 를 탄생시킨 곳이기에 쿠버네티스를 운영하기에 적합한 환경이다.
<br>GCP 시작<br>$ brew install --cask google-cloud-sdk
Copy<br>GCP 로그인<br>$ gcloud auth login `ACCOUNT`
Copy<br>Project 생성 및 region , zone 생성<br>
$ gcloud projects create example-foo-bar-1 --name="Happy project" --labels=type=happy

$ export CLOUDSDK_CORE_PROJECT=$PROJECT_ID

$ gcloud config set project PROJECT_ID

$ gcloud config set compute/region REGION

$ gcloud config set compute/zone ZONE

$ gcloud config get-value compute/region

$ gcloud config get-value compute/zone

$ gcloud compute project-info add-metadata \
   --metadata google-compute-default-region=REGION,google-compute-default-zone=ZONE
   
$ gcloud init

Copy<br>
<br><a data-href="GKE" href="docker-&amp;-k8s/gke.html" class="internal-link" target="_self" rel="noopener">GKE</a>
<br><br><a data-tooltip-position="top" aria-label="https://cloud.google.com/?hl=en" rel="noopener" class="external-link" href="https://cloud.google.com/?hl=en" target="_blank">GCP 공식문서</a><br>
<a data-tooltip-position="top" aria-label="https://support.google.com/a/thread/74530265/can-t-remove-google-cloud-project-due-to-dialogflow?hl=en" rel="noopener" class="external-link" href="https://support.google.com/a/thread/74530265/can-t-remove-google-cloud-project-due-to-dialogflow?hl=en" target="_blank">project 선취권 문제로 삭제 안될 때</a><br>
<a data-tooltip-position="top" aria-label="https://developer.hashicorp.com/terraform/tutorials/gcp-get-started/google-cloud-platform-build" rel="noopener" class="external-link" href="https://developer.hashicorp.com/terraform/tutorials/gcp-get-started/google-cloud-platform-build" target="_blank">GCP&amp;Terrform 설정</a><br>
<a data-tooltip-position="top" aria-label="https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_service_account_key_creation" rel="noopener" class="external-link" href="https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_service_account_key_creation" target="_blank">서비스계정키생성disabled</a>]]></description><link>gcp.html</link><guid isPermaLink="false">GCP.md</guid><pubDate>Fri, 12 Jan 2024 05:05:34 GMT</pubDate></item><item><title><![CDATA[gRPC]]></title><description><![CDATA[ 
 <br>gRPC는 Cloud Native Computing Foundation에서 관리하는 오픈 소스 API 아키텍처 및 시스템<br>RPC에서 클라이언트-서버 통신은 클라이언트 API 요청이 로컬 작업이거나 요청이 내부 서버 코드인 것처럼 작동<br><br><a rel="noopener" class="external-link" href="https://aws.amazon.com/ko/compare/the-difference-between-grpc-and-rest/" target="_blank">https://aws.amazon.com/ko/compare/the-difference-between-grpc-and-rest/</a>]]></description><link>grpc.html</link><guid isPermaLink="false">gRPC.md</guid><pubDate>Tue, 05 Mar 2024 08:55:16 GMT</pubDate></item><item><title><![CDATA[Helm & Summary]]></title><description><![CDATA[ 
 <br>
<br>어플리케이션 코드가 올라가 있는&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/iamchoiz/demo-app-gitaction-argocd" rel="noopener" class="external-link" href="https://github.com/iamchoiz/demo-app-gitaction-argocd" target="_blank">App repository</a><br>
코드를 컨테이너로 빌드하여 Artifact Repository로 PUSH
<br>어플리케이션 Manifest(k8 POD를 만들기 위한)가 존재하는 Config Repo. k8 Resource 배포를 위한 Kustomize 형식의 yaml 파일들입니다.
<br><br>Helm chart 의 Life cycle 을 이해하면 조금 더 고급스러운 chart 를 만들 수 있다. 예를 들면 이전 chart 의 애플리케이션에서 postgresql DB를 사용하기 때문에 사용자, 데이터베이스, 테이블을 생성해야 하는 경우를 생각해 보자. 차트가 배포될 때 애플리케이션이 실행되기 이전에 해당 작업들을 할 수 있다면 chart 배포 한 번으로 모든 배포를 끝낼 수 있으니 멋진 일이다.<br><br>이러한 hook 의 종류는 아래와 같다.<br><br>hook 을 정의하는 것은 Annotation 으로 하며, 앞에서 설명한 시나리오의 경우에는 pre-install hook 을 사용하는 것이 적절하기 때문에 "helm.sh/hook": pre-install 로 설정한다. 또한 이런 단발성 호출의 경우에는 Job 으로 설정하는 것이 좋다.<br>apiVersion: batch/v1
kind: Job
metadata:
...
  annotations:
    "helm.sh/hook": pre-install
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation
Copy<br>hook-weight 는 낮을 수록 우선순위가 높으며, hook-delete-policy 의 before-hook-creation 은 hook 으로 실행된 리소스를 다음 hook 이 실행될 때 까지 지우지 않고 남겨둔다는 의미이다. policy 는 아래와 같이 3가지가 있다.<br><br>그럼 postgresql 을 설치하고 사용자, 데이터베이스, 테이블을 생성하는 pre-install hook 을 작성해 보자.<br><br>bitnami chart repo 에서 postgresql 을 다운받아 설치한다.<br>$ helm repo add bitnami https://charts.bitnami.com/bitnami
$ helm repo update
$ helm upgrade -i postgresql bitnami/postgresql --version 10.8.0 -n decapod-db --create-namespace \
--set postgresqlPassword=password \
--set persistence.enabled=true \
--set persistence.storageClass=rbd \
--set persistence.size=10Gi
Copy<br>chart 의 value 값을 필요한 부분만 override 하였다. db user 는 postgres 이며 db password는 password 로 설치했다. 테스트 환경에서는 외부 스토리지를 제공하고 있어 10Gi 로 설정하였다.<br>$ kubectl get pods -n decapod-db
NAME                      READY   STATUS    RESTARTS   AGE
postgresql-postgresql-0   1/1     Running   0          35h


$ kubectl get svc -n decapod-db
NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
postgresql            ClusterIP   10.233.46.14           5432/TCP   35h
postgresql-headless   ClusterIP   None                   5432/TCP   35h
Copy<br><br>chart 가 설치될 때 한 번 실행되면 되므로 Job 타입으로 리소스를 작성한다. psql 명령을 사용할 수 있는 컨테이너 이미지를 활용하고 수행할 명령어들은 쉘 스크립트로 작성하였다.<br>{chart_source_home}/templates/pre-install-job.yaml

apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "tks-contract.fullname" . }}
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "tks-contract.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      name: {{ include "tks-contract.fullname" . }}
    spec:
      restartPolicy: Never
      containers:
      - name: pre-install-job
        image: "bitnami/postgresql:11.12.0-debian-10-r44"
        env:
        - name: DB_ADMIN_USER
          value: {{ .Values.db.adminUser }}
        - name: PGPASSWORD
          value: {{ .Values.db.adminPassword }}
        - name: DB_NAME
          value: {{ .Values.db.dbName }}
        - name: DB_USER
          value: {{ .Values.args.dbUser }}
        - name: DB_PASSWORD
          value: {{ .Values.args.dbPassword }}
        - name: DB_URL
          value: {{ .Values.args.dbUrl }}
        - name: DB_PORT
          value: "{{ .Values.args.dbPort }}"
        command:
        - /bin/bash
        - -c
        - -x
        - |
          # check if ${DB_NAME} database already exists.
          psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER} -lqt | cut -d \| -f 1 | grep -qw ${DB_NAME}
          if [[ $? -ne 0 ]]; then
            psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER} -c "CREATE DATABASE ${DB_NAME};"
          fi

          # check if ${DB_USER} user already exists.
          psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER} -tc '\du' | cut -d \| -f 1 | grep -qw ${DB_USER}
          if [[ $? -ne 0 ]]; then
            psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER} -c "create user ${DB_USER} SUPERUSER password '${DB_PASSWORD}';"
          fi

          # check if contracts table in tks database already exists.
          psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER} -d ${DB_NAME} -tc '\dt' | cut -d \| -f 2 | grep -qw contracts
          if [[ $? -ne 0 ]]; then
            echo """
              \c ${DB_NAME};
              CREATE TABLE contracts
              (
                  contractor_name character varying(50) COLLATE pg_catalog."default",
                  id uuid primary key,
                  available_services character varying(50)[] COLLATE pg_catalog."default",
                  updated_at timestamp with time zone,
                  created_at timestamp with time zone
              );
              CREATE UNIQUE INDEX idx_contractor_name ON contracts(contractor_name);
              ALTER TABLE contracts CLUSTER ON idx_contractor_name;
              INSERT INTO contracts(
                contractor_name, id, available_services, updated_at, created_at)
                VALUES ('tester', 'edcaa975-dde4-4c4d-94f7-36bc38fe7064', ARRAY['lma'], '2021-05-01'::timestamp, '2021-05-01'::timestamp);

              CREATE TABLE resource_quota
              (
                  id uuid primary key,
                  cpu bigint,
                  memory bigint,
                  block bigint,
                  block_ssd bigint,
                  fs bigint,
                  fs_ssd bigint,
                  contract_id uuid,
                  updated_at timestamp with time zone,
                  created_at timestamp with time zone
              );
            """ | psql -h ${DB_URL} -p ${DB_PORT} -U ${DB_ADMIN_USER}
          fi
Copy<br>{chart_source_home}/values.yaml

args:
  port: 9110
  dbUrl: postgresql.decapod-db.svc
  dbPort: 5432
  dbUser: tksuser
  dbPassword: password

db:
  adminUser: postgres
  adminPassword: password
  dbName: tks
Copy<br>컨테이너에서 필요한 값들(db superuser admin 과 password, db url, db port 등)은 env 로 전달한다. 참고로 postgresql 은 psql 로 접속할 때 패스워드를 전달하는 아규먼트가 없다. 대신 환경 변수로 다음과 같이 설정하면 패스워드를 사용하여 접속할 수 있다. ($ export PGPASSWORD=password)<br>
<br>먼저 DB 에 해당 database 가 존재하는 조회하고 없으면 database 를 생성한다.
<br>DB User 가 존재하는지 조회하고 없으면 새로운 DB User 를 생성한다.
<br>Table 이 존재하는지 조회하고 없으면 Table 을 생성한다. Table 을 생성하기 위해 psql 로 접속 시에 해당 database 에 접속할 수 있지만 (-d database명 옵션 사용), "\c database명" 으로 database 를 선택할 수 있다는 것을 보여주기 위해 이 부분을 추가하였다.
<br>chart 를 배포하면 다음과 같이 job 이 실행됨을 알 수 있다.<br>$ kubectl get pods -n tks
NAME                               READY   STATUS      RESTARTS   AGE
tks-contract-h5468                 0/1     Completed   0          31h


$ kubectl logs tks-contract-h5468 -n tks
+ psql -h postgresql.decapod-db.svc -p 5432 -U postgres -lqt
+ cut -d '|' -f 1
+ grep -qw tks
+ [[ 0 -ne 0 ]]
+ psql -h postgresql.decapod-db.svc -p 5432 -U postgres -tc '\du'
+ cut -d '|' -f 1
+ grep -qw tksuser
+ [[ 0 -ne 0 ]]
+ psql -h postgresql.decapod-db.svc -p 5432 -U postgres -d tks -tc '\dt'
+ cut -d '|' -f 2
+ grep -qw contracts
+ [[ 0 -ne 0 ]]
Copy]]></description><link>helm-&amp;-summary.html</link><guid isPermaLink="false">Helm &amp; Summary.md</guid><pubDate>Tue, 30 Jan 2024 02:55:57 GMT</pubDate></item><item><title><![CDATA[Ingress controller 역할을 수행]]></title><description><![CDATA[ 
 <br><br>
<br>service 보호, 연결, 모니터링
<br>통신에 대한 측정
<br>traffic에 대한 시각화 
<br>kiali
<br>Service Mesh<br>
<br>Application에 추가할 수 있는 전용 인프라 계층
<br>Traffic Control<br>
<br>virtual service : 어느 host 혹은 service로 routing 할지, 트래픽(weight)를 어느 정도로 할지
<br>gateway : 어느 host의 요청, 포트 등을 처리할 지
<br><br>
<br><a data-tooltip-position="top" aria-label="https://istio.io/latest/about/service-mesh/" rel="noopener" class="external-link" href="https://istio.io/latest/about/service-mesh/" target="_blank">Service Mesh - Istio</a>
<br><a data-tooltip-position="top" aria-label="https://kr.linkedin.com/pulse/istio%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C-sean-lee" rel="noopener" class="external-link" href="https://kr.linkedin.com/pulse/istio%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%EC%A4%91%EC%9A%94%ED%95%A0%EA%B9%8C-sean-lee" target="_blank">istio는-무엇이고-왜-중요할까</a>
]]></description><link>istio.html</link><guid isPermaLink="false">Istio.md</guid><pubDate>Tue, 06 Feb 2024 02:08:16 GMT</pubDate></item><item><title><![CDATA[IT Terms]]></title><description><![CDATA[<a class="tag" href="?query=tag:DevOps" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DevOps</a> <a class="tag" href="?query=tag:Web3" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Web3</a> <a class="tag" href="?query=tag:DC/OS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DC/OS</a> <a class="tag" href="?query=tag:Zero-trust" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Zero-trust</a> <a class="tag" href="?query=tag:Heatmap" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Heatmap</a> <a class="tag" href="?query=tag:Heap_Memory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Heap_Memory</a> <a class="tag" href="?query=tag:TPS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#TPS</a> <a class="tag" href="?query=tag:PWA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#PWA</a> <a class="tag" href="?query=tag:RBAC" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#RBAC</a> <a class="tag" href="?query=tag:ABAC" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ABAC</a> <a class="tag" href="?query=tag:MAU" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MAU</a> <a class="tag" href="?query=tag:Type" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Type</a> <a class="tag" href="?query=tag:Interface" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Interface</a> <a class="tag" href="?query=tag:Const" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Const</a> <a class="tag" href="?query=tag:Let" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Let</a> <a class="tag" href="?query=tag:Serverless" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Serverless</a> <a class="tag" href="?query=tag:NFS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#NFS</a> <a class="tag" href="?query=tag:Vagrant" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Vagrant</a> <a class="tag" href="?query=tag:Protocol" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Protocol</a> <a class="tag" href="?query=tag:Virtual_box" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Virtual_box</a> <a class="tag" href="?query=tag:Warmstart" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Warmstart</a> <a class="tag" href="?query=tag:Coldstart" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Coldstart</a> <a class="tag" href="?query=tag:Enum" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Enum</a> <a class="tag" href="?query=tag:CIDR" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CIDR</a> <a class="tag" href="?query=tag:Multicast" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Multicast</a> <a class="tag" href="?query=tag:IPv4" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#IPv4</a> <a class="tag" href="?query=tag:IPv6" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#IPv6</a> <a class="tag" href="?query=tag:HTTP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#HTTP</a> <a class="tag" href="?query=tag:HTTPS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#HTTPS</a> <a class="tag" href="?query=tag:SSL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SSL</a> <a class="tag" href="?query=tag:TLS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#TLS</a> <a class="tag" href="?query=tag:Busybox" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Busybox</a> <a class="tag" href="?query=tag:DHCP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DHCP</a> <a class="tag" href="?query=tag:URI" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#URI</a> <a class="tag" href="?query=tag:URL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#URL</a> <a class="tag" href="?query=tag:L2_Switch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#L2_Switch</a> <a class="tag" href="?query=tag:MAC주소" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MAC주소</a> <a class="tag" href="?query=tag:Broadcast" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Broadcast</a> <a class="tag" href="?query=tag:IP주소" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#IP주소</a> <a class="tag" href="?query=tag:port" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#port</a> <a class="tag" href="?query=tag:process" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#process</a> <a class="tag" href="?query=tag:CRM" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CRM</a> <a class="tag" href="?query=tag:Endpoint" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Endpoint</a> <a class="tag" href="?query=tag:Switching" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Switching</a> <a class="tag" href="?query=tag:Switch" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Switch</a> <a class="tag" href="?query=tag:Router" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Router</a> <a class="tag" href="?query=tag:Routing" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Routing</a> <a class="tag" href="?query=tag:CSMA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CSMA</a> <a class="tag" href="?query=tag:IEEE802" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#IEEE802</a> <a class="tag" href="?query=tag:CSMA/CD" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CSMA/CD</a> <a class="tag" href="?query=tag:CSMA/CA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CSMA/CA</a> <a class="tag" href="?query=tag:Overlay_Network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Overlay_Network</a> <a class="tag" href="?query=tag:MAC" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#MAC</a> <a class="tag" href="?query=tag:Broadcast" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Broadcast</a> <a class="tag" href="?query=tag:Unicast" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Unicast</a> <a class="tag" href="?query=tag:Multicast" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Multicast</a> <a class="tag" href="?query=tag:STP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#STP</a> <a class="tag" href="?query=tag:Domain" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Domain</a> <a class="tag" href="?query=tag:DNS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DNS</a> <a class="tag" href="?query=tag:public_subnet" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#public_subnet</a> <a class="tag" href="?query=tag:CDN" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CDN</a> <a class="tag" href="?query=tag:private_subnet" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#private_subnet</a> <a class="tag" href="?query=tag:connection_pool" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#connection_pool</a> <a class="tag" href="?query=tag:NAT" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#NAT</a> <a class="tag" href="?query=tag:공개키_암호화" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#공개키_암호화</a> <a class="tag" href="?query=tag:RTO" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#RTO</a> <a class="tag" href="?query=tag:RPO" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#RPO</a> <a class="tag" href="?query=tag:SLA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SLA</a> <a class="tag" href="?query=tag:SLI" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SLI</a> <a class="tag" href="?query=tag:SLA" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SLA</a> <a class="tag" href="?query=tag:SRE" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#SRE</a> <a class="tag" href="?query=tag:BlackboxTest" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#BlackboxTest</a> <a class="tag" href="?query=tag:3-tier-architecture" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#3-tier-architecture</a> <a class="tag" href="?query=tag:webRTC" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#webRTC</a> <a class="tag" href="?query=tag:proxy" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#proxy</a> 
 <br><br><a href=".?query=tag:DevOps" class="tag" target="_blank" rel="noopener">#DevOps</a><br>
<br>인프라 구축(세팅)부터 배포, 운영까지의 과정을 최적화하는 업무를 하는 사람
<br>탈중앙 - 블록체인의 핵심. <a href=".?query=tag:Web3" class="tag" target="_blank" rel="noopener">#Web3</a>
<br>내가 만든 서비스를 많은 고객들이 이용해주었으면 좋겠다.
<br><a href=".?query=tag:DC/OS" class="tag" target="_blank" rel="noopener">#DC/OS</a> : the Distributed Cloud Operating System<br>
<br>여러 개의 서버가 함께 운영되는 환경을 하나의 서버처럼 손쉽게 운영하고 관리하기 위한 목적으로 활용되는 솔루션
<br><a href=".?query=tag:Zero-trust" class="tag" target="_blank" rel="noopener">#Zero-trust</a><br>
<br>보안 모델
<br>모든 사용자, 기기, 구성요소가 조직 내부에 있는지 외부에 있는지 관계 없이 항상 신뢰할 수 없는 것으로 간주한다.
<br><a data-tooltip-position="top" aria-label="https://cloud.google.com/learn/what-is-zero-trust?hl=ko#:~:text=%EC%A0%9C%EB%A1%9C%20%ED%8A%B8%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EC%95%94%EC%8B%9C%EC%A0%81,%EC%88%98%20%EC%97%86%EB%8A%94%20%EA%B2%83%EC%9C%BC%EB%A1%9C%20%EA%B0%84%EC%A3%BC%EB%90%A9%EB%8B%88%EB%8B%A4." rel="noopener" class="external-link" href="https://cloud.google.com/learn/what-is-zero-trust?hl=ko#:~:text=%EC%A0%9C%EB%A1%9C%20%ED%8A%B8%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94%20%EC%95%94%EC%8B%9C%EC%A0%81,%EC%88%98%20%EC%97%86%EB%8A%94%20%EA%B2%83%EC%9C%BC%EB%A1%9C%20%EA%B0%84%EC%A3%BC%EB%90%A9%EB%8B%88%EB%8B%A4." target="_blank">zero-trust model</a>
<br><a href=".?query=tag:Heatmap" class="tag" target="_blank" rel="noopener">#Heatmap</a> <br>
<br>히트맵은 데이터의 값을 컬러로 변환시켜 열 분포 형태로 보여주며 시각적인 분석을 가능하게 하는 데이터 시각화 기법
<br><a href=".?query=tag:Heap_Memory" class="tag" target="_blank" rel="noopener">#Heap_Memory</a><br>
<br>힙 메모리는 프로그램에서 동적으로 할당된 메모리를 관리하는 데 사용되는 영역
<br><a href=".?query=tag:TPS" class="tag" target="_blank" rel="noopener">#TPS</a> (Transaction Per Second)<br>
<br>초당 트랜잭션의 개수
<br><a href=".?query=tag:PWA" class="tag" target="_blank" rel="noopener">#PWA</a><br>
<br>Progressive Web Apps
<br>네이티브 앱과 유사하다. 
<br>사용자가 앱을 다운로드하거나 업데이트 할 필요 없이 웹 브라우저를 통해 앱을 바로 사용 가능.
<br><a href=".?query=tag:RBAC" class="tag" target="_blank" rel="noopener">#RBAC</a><br>
<br>Role-Based Access Control
<br>역할 별로  액세스 권한을 부여한다.
<br><a href=".?query=tag:ABAC" class="tag" target="_blank" rel="noopener">#ABAC</a><br>
<br>Attribute-Based Access Control
<br>사용자 특성, 개체 특성, 작업 유형 등에 따라 액세스를 결정. 보다 세부적인 control이 가능하다.
<br><a href=".?query=tag:MAU" class="tag" target="_blank" rel="noopener">#MAU</a><br>
<br>Monthly Active User
<br><a href=".?query=tag:Type" class="tag" target="_blank" rel="noopener">#Type</a> vs <a href=".?query=tag:Interface" class="tag" target="_blank" rel="noopener">#Interface</a> <br>
<br>Type<br>
data의 구조적인 특성을 나타낸다.<br>
&amp; 기호를 이용해 확장할 수 있다.<br>
원시 값, tuple, union 타입 선언이 가능하다.<br>
computed value 사용 가능
<br>
<br>Interface<br>
클래스나 객체의 행동에 대한 추상적인 계약을 정의한다.<br>
선언적 확장(같은 이름의 interface 선언 시, 자동으로 확장)이 가능하다.<br>
extends 키워드를 이용해 확장할 수 있다.<br>
Object type을 설정할 때 사용 가능하다.
<br><a href=".?query=tag:Const" class="tag" target="_blank" rel="noopener">#Const</a> vs <a href=".?query=tag:Let" class="tag" target="_blank" rel="noopener">#Let</a><br>
<br>Const는 재할당이 불가능
<br>let은 재할당이 가능
<br><a href=".?query=tag:Serverless" class="tag" target="_blank" rel="noopener">#Serverless</a><br>
<br>BaaS (Backend as a Service)나 FaaS (Function as a Service / AWS Lambda, Azure Functions) 등에 의존하여 앱이 동작하는 것을 의미한다.<br>
실제 '물리적' 서버가 없는 것으로 이해해야 한다. 
<br>장점 - on-demand 방식이라는 장점이다.
<br>단점 - 검색 엔진처럼 속도가 생명인 application에 이상적인 방법은 아니다. 항시 실행 중이 아니라 trigger에 의해 서버를 실행하고 종료하기 때문에 대기 시간이 오래 걸린다.
<br><a href=".?query=tag:NFS" class="tag" target="_blank" rel="noopener">#NFS</a><br>
→ 네트워크에서 파일 시스템을 공유. K8s의 pod에서 persistent 볼륨 학습 환경으로 사용.<br><a href=".?query=tag:Vagrant" class="tag" target="_blank" rel="noopener">#Vagrant</a><br>
→ virtual box와 연계하여 가상 머신 관리를 자동화해 주는 도구.<br><a href=".?query=tag:Protocol" class="tag" target="_blank" rel="noopener">#Protocol</a><br>
원거리에 있는 기계 사이에 정확한 데이터 송수신을 위한 통신 규약.<br><a href=".?query=tag:Virtual_box" class="tag" target="_blank" rel="noopener">#Virtual_box</a><br>
→ windows, mac, linux 서버에서 사용 가능한 hyper visor, vagrant의 백엔드로서 학습용 가상 환경 구축에 사용.<br><a href=".?query=tag:Warmstart" class="tag" target="_blank" rel="noopener">#Warmstart</a> vs <a href=".?query=tag:Coldstart" class="tag" target="_blank" rel="noopener">#Coldstart</a> in Lambda<br>
<br>Warm start : 이미 실행 준비가 완료된 상태
<br>Cold start : 배포 패키지의 크기와 코드의 초기화 시간에 따라 새 실행환경으로 호출을 라우팅할 때 지연 시간이 발생하는 현상.
<br><a href=".?query=tag:Enum" class="tag" target="_blank" rel="noopener">#Enum</a> ✅ 열거형 변수<br>
<br>TypeScript가 자체적으로 구현하는 기능(JS not support)<br>
왜 권장하지 않나? tree-shaking 불가. (export했지만 어디에서도 import하지 않은 모듈/코드) 사용하지 않는 코드를 삭제하는 기능. 
<br><a href=".?query=tag:CIDR" class="tag" target="_blank" rel="noopener">#CIDR</a> ✅ 클래스없는 도메인간 라우팅 기법<br>
<br><a data-tooltip-position="top" aria-label="https://aws.amazon.com/ko/what-is/cidr/" rel="noopener" class="external-link" href="https://aws.amazon.com/ko/what-is/cidr/" target="_blank">What is CIDR</a> / <a data-tooltip-position="top" aria-label="https://kim-dragon.tistory.com/154" rel="noopener" class="external-link" href="https://kim-dragon.tistory.com/154" target="_blank">CIDR 쉽게 계산하기</a> / <a data-tooltip-position="top" aria-label="https://hwannny.tistory.com/86" rel="noopener" class="external-link" href="https://hwannny.tistory.com/86" target="_blank">CIDR를 통해 알아보는 서브넷마스크</a><br>
→ Classless Inter-Domain Routing (사이더)
<br>이전에는 IP 주소는 class 기반이었기에 IP 주소 할당이 비효율적+공간 낭비로 이어졌음.<br>
CIDR를 사용하면 class 기반이 아닌 네트워크 및 호스트 주소를 검색하여 유연한 IP 주소 할당이 가능함.<br>
데이터 라우팅 효율성을 향상시키는 IP 주소 할당 방법
<br>🔑 IP주소와 subnet mask를 동시에 표기하는 기법. subnet 분할이 유연해진다는 장점<br>
IP - 210.77.8.155, 서브넷 마스크 -&nbsp;255.255.255.192 일경우<br>
210.77.8.155/26와 같이 표기한다.
<br>
<br>class 기반<br>
Class A : 0.0.0.0 ~ 127.255.255.255<br>
Class B :  128.0.0.0 ~ 172.31.255.255<br>
Class C : 192.0.0.0 ~ 223.255.255.255<br>
Class D : 224.0.0.0 ~ 239.255.255.255 → <a href=".?query=tag:Multicast" class="tag" target="_blank" rel="noopener">#Multicast</a> 용으로 실제 IP 주소가 할당 X<br>
Class E : 240.0.0.0 ~ 255.255.255.255 → 기타 목적으로 예약되어, 실제 IP 주소가 할당 X
<br><a href=".?query=tag:IPv4" class="tag" target="_blank" rel="noopener">#IPv4</a> vs <a href=".?query=tag:IPv6" class="tag" target="_blank" rel="noopener">#IPv6</a> ✅ IPv6는 IPv4를 대체하도록 설계된 네트워크 주소 지정 시스템.<br>
<br>부족한 주소 문제 해결을 위한 대안이 IPv6
<br>IPv4 : 32 비트 (2의 32승, 약 43억개)
<br>IPv6 : 128 비트 (2의 128승, 340간 개) → DHCP 서버가 없어도 IP 주소를 자동 할당 가능함.
<br><a href=".?query=tag:HTTP" class="tag" target="_blank" rel="noopener">#HTTP</a> vs <a href=".?query=tag:HTTPS" class="tag" target="_blank" rel="noopener">#HTTPS</a> ✅ https는 http+암호화가 추가된 프로토콜<br>
<img alt="200" src="https://www.cloudflare.com/img/learning/security/glossary/what-is-ssl/http-vs-https.svg" referrerpolicy="no-referrer"><br>
<br><a data-tooltip-position="top" aria-label="https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/" rel="noopener" class="external-link" href="https://aws.amazon.com/ko/compare/the-difference-between-https-and-http/" target="_blank">http vs https</a>
<br>client와 server 간 통신을 위한 프로토콜
<br>HTTP(80)는 암호화되지 않는 데이터를, HTTPS(443)는 암호화된 데이터를 전송한다. <br> 로드 속도도 더 빠르고 참조 링크도 잘 추적한다.
<br>HTTPS(Hypertext Transfer Protocol Secure) 🔑 HTTP의 확장 버전. 안전한 버전
<br>Secure - HTTP 요청 및 응답을 SSL 및 TLS 기술에 결합
<br><a href=".?query=tag:SSL" class="tag" target="_blank" rel="noopener">#SSL</a> vs <a href=".?query=tag:TLS" class="tag" target="_blank" rel="noopener">#TLS</a><br>
<br>OSI 7 layer 중 Layer 6 인 Presentation Layer에서 사용되는 프로토콜
<br><a href=".?query=tag:Busybox" class="tag" target="_blank" rel="noopener">#Busybox</a><br>
<br>경량의 리눅스 배포 중 하나로, 여러 유틸리티와 명령줄 도구를 제공하는 작은 이미지.
<br>많은 일반적인 UNIX 유틸리티의 작은 버전을 하나의 작은 실행 파일로 결합한다.
<br><a href=".?query=tag:DHCP" class="tag" target="_blank" rel="noopener">#DHCP</a>  ✅ 네트워크 설정을 자동으로 해주는 방법<br><img alt="DHCP.png" src="excalidraw/dhcp.png" style="width: 400px; max-width: 100%;"><br>
<a data-tooltip-position="top" aria-label="https://learn.microsoft.com/ko-kr/windows-server/networking/technologies/dhcp/dhcp-top" rel="noopener" class="external-link" href="https://learn.microsoft.com/ko-kr/windows-server/networking/technologies/dhcp/dhcp-top" target="_blank">Dynamic Host Configuration Protocol</a><br>
공유기에 보통 DHCP server가 내장되어 있고, 컴퓨터에는 보통 DHCP client가 있다.<br>
broadcast와 변칙적인 UDP를 사용해서 DHCP server - DHCP client 사이 필요한 정보를 교환한다.<br><a href=".?query=tag:URI" class="tag" target="_blank" rel="noopener">#URI</a> vs <a href=".?query=tag:URL" class="tag" target="_blank" rel="noopener">#URL</a> ✅ URI는 식별자, URL은 식별자+위치<br>
<br>URI (Uniform Resource Identifier)<br>
인터넷 상의 리소스 자체를 식별하는 고유한 문자열 시퀀스<br>
ex) elancer.co.kr
<br>URL (Uniform Resource Locator)<br>
리소스의 위치를 나타내기 위한 규약.	URI + 프로토콜이 결합된 형태. (http, https)<br>
ex) <a rel="noopener" class="external-link" href="https://elancer.co.kr" target="_blank">https://elancer.co.kr</a>
<br><a href=".?query=tag:L2_Switch" class="tag" target="_blank" rel="noopener">#L2_Switch</a><br>
<br>MAC 주소 기반으로 통신한다. MAC 주소는 48bit
<br>L2 Access : endpoint와 직접 맞닿는 스위치 
<br>L2 Distribution : Router로 데이터를 보내는 스위치
<br>uplink : 상위 계층 스위치로 연결되는 Line (= 더 큰 네트워크로 나가는 역할)
<br><a href=".?query=tag:MAC주소" class="tag" target="_blank" rel="noopener">#MAC주소</a>  ✅ 기기에 존재하는 NIC를 특정하는 주소 (NIC에 대한 식별자)<br>
<br>Media Access Control Address
<br>48 bit
<br>데이터링크 계층에서 이용된다.<br>
PC를 비롯한 각종 단말, 프린터 같은 각종 기기에 존재하는&nbsp;NIC를 특정하는 주소&nbsp;<br> = 이더넷용 주소<br>
FF:FF:FF:FF:FF:FF는 이더넷에 접속한 모든 NIC를 대상으로 일제히 송신한다 =&nbsp;<a href=".?query=tag:Broadcast" class="tag" target="_blank" rel="noopener">#Broadcast</a> 주소<br>
= h/w의 address<br>
데이터 링크 계층에서 사용되며, 물리적인 네트워크 장비를 식별하는데 사용된다.
<br>NIC (= Network Interface Controller, LAN 카드 / Network Interface Card)<br>
NIC에 여러 개의 IP를 바인딩 가능
<br><a href=".?query=tag:IP주소" class="tag" target="_blank" rel="noopener">#IP주소</a> ✅ Host에 대한 식별자<br>
<br>Host : 네트워크에 연결된 컴퓨터
<br><a href=".?query=tag:port" class="tag" target="_blank" rel="noopener">#port</a> ✅ Process에 대한 식별자<br>
<br>컴퓨터가 data를 어느 process에게 전달해야 되는지를 알려주는 unique한 번호
<br>전송 계층에서 사용되는 기술
<br>sender가 data를 보낼 때 + 수신자 컴퓨터의 process의 port 번호
<br><a href=".?query=tag:process" class="tag" target="_blank" rel="noopener">#process</a> ✅ 동작 중인 프로그램<br>
<br>프로그램이 실행되어서 메모리에 올라간 상태
<br><a href=".?query=tag:CRM" class="tag" target="_blank" rel="noopener">#CRM</a><br><a href=".?query=tag:Endpoint" class="tag" target="_blank" rel="noopener">#Endpoint</a><br>
<br>API가 server에서 resource에 접근 가능하도록 하는 URL
<br><a href=".?query=tag:Switching" class="tag" target="_blank" rel="noopener">#Switching</a> ✅ 네트워크 내부에서 패킷 전송을 담당 (물리적인 전송)<br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=oAbukpZbpTg" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=oAbukpZbpTg" target="_blank">스위칭 개념</a> /  <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=jKCV6s6FKrg" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=jKCV6s6FKrg" target="_blank">스위치 기능 </a> /  <a data-tooltip-position="top" aria-label="https://catsbi.oopy.io/315731e3-1730-4690-ad8f-663e0af7621b" rel="noopener" class="external-link" href="https://catsbi.oopy.io/315731e3-1730-4690-ad8f-663e0af7621b" target="_blank">스위치:2계층 장비</a><br><a href=".?query=tag:Switch" class="tag" target="_blank" rel="noopener">#Switch</a> : 교차로  ✅ 네트워크 내에서 packet을 받아 필요한 곳으로 보내주는 역할<br>
→ Switch는 기본적으로 L2 장비<br>
<br>Learning : Source MAC address를 기반으로 MAC address table을 만드는 기능
<br>Forwarding : Destination MAC Address가 연결되어 있는 port로 frame을 전달하는 기능
<br>Filtering : 프레임이 유입된 port로 다시 frame을 전송하지 않는 기능
<br>Flooding : MAC 주소 테이블에 목적지에 MAC에 대한 정보가 없을 경우 frame을 모든 port로 전송하는 기능 = 테이블에 없는 도착지 주소를 가진 패킷이 들어오면 스위치는 전체 포트로 패킷을 전송한다.
<br><a href=".?query=tag:Router" class="tag" target="_blank" rel="noopener">#Router</a> ✅ 최적 경로 선택<br>
기본적으로 L3 Switch. Internet은 router의 집합체<br>
Packet이 Router에 도착하면, 이 Router들 간 특정 프로토콜로 통신하며 최적화된 경로를 찾는데, 이 경로 선택의 base가 되는 것이 ⭐️ Routing Table (이정표)<br><a href=".?query=tag:Routing" class="tag" target="_blank" rel="noopener">#Routing</a> Protocol  ✅ 라우터가 패킷을 식별하고 네트워크 경로를 선택하는 프로세스<br>
<br><a data-tooltip-position="top" aria-label="https://aws.amazon.com/ko/what-is/routing/" rel="noopener" class="external-link" href="https://aws.amazon.com/ko/what-is/routing/" target="_blank"># 라우팅이란 무엇입니까?</a>
<br>라우팅 및 스위칭(MPLS, BGP, OSPF, SR, VXLAN 등)                                                  

<br>OSPF (Open Shortest Path First) : 여러 경로 중 최소 link cost인 경로를 선택 
<br><a data-tooltip-position="top" aria-label="https://atthis.tistory.com/6" rel="noopener" class="external-link" href="https://atthis.tistory.com/6" target="_blank">VXLAN</a>  VLAN + X(eXtensible) : 기존 VLAN이 제공할 수 있는 규모 이상으로 네트워크 segmentation을 수행하는 데 사용된다. 
<br>SR (Segment Routing) : 라우터가 packet header를 알아서 읽어서, 이를 목적지까지 전송 
<br>BGP (Border Gateway Protocol) : 유일한 외부 Gateway 프로토콜. 규모가 큰 망을 지원
<br>MPLS (Multi Protocol&nbsp;Label&nbsp;Switching) : IP 주소가 아닌 레이블을 사용하여 네트워크 트래픽을 라우팅하는 기술 


<br><a href=".?query=tag:CSMA" class="tag" target="_blank" rel="noopener">#CSMA</a> (Carrier Sense Multiple Access) <a href=".?query=tag:IEEE802" class="tag" target="_blank" rel="noopener">#IEEE802</a>.11<br>
<br>반송파 감지 다중 접근
<br>전송하기 이전에 먼저 매체의 상태를 확인 (전송 이전에 감지)
<br><a href=".?query=tag:CSMA/CD" class="tag" target="_blank" rel="noopener">#CSMA/CD</a>&nbsp;(Carrier Sense Multiple Access with Collision Detection) : 반송파가 감지되지 않으면 컴퓨터가 전송 매체를 사용하지 않는 것으로 판단하여 데이터를 전송한다.
<br><a href=".?query=tag:CSMA/CA" class="tag" target="_blank" rel="noopener">#CSMA/CA</a>&nbsp;(Carrier Sense Multiple Access with Collision Avoidance)
<br><a href=".?query=tag:Overlay_Network" class="tag" target="_blank" rel="noopener">#Overlay_Network</a>  ✅  물리 네트워크 위에 성립되는 가상의 컴퓨터 네트워크<br>
<br><a href=".?query=tag:MAC" class="tag" target="_blank" rel="noopener">#MAC</a> Over IP/UDP 기술 기반
<br><a href=".?query=tag:Broadcast" class="tag" target="_blank" rel="noopener">#Broadcast</a> / <a href=".?query=tag:Unicast" class="tag" target="_blank" rel="noopener">#Unicast</a> / <a href=".?query=tag:Multicast" class="tag" target="_blank" rel="noopener">#Multicast</a> ✅ 네트워크 통신에서 사용되는 데이터 전송 방식<br>
<br>브로드캐스트 : 네트워크 상에 연결된 모든 장치에 데이터를 전송하는 방식. 주로 소규모 네트워크
<br>유니캐스트 : 하나의 송신자가 특정 수신자 에게만 데이터를 전송하는 방식. 일반적으로 가장 효율적인 전송 방식
<br>멀티캐스트 : 송신자가 그룹 내의 여러 수신자에게 데이터를 전송하는 방식. ex) 멀티 스트리밍
<br>
<br>broadcast strom - 스위치가 broadcast 트래픽을 계속 발생시켜 네트워크 다운을 초래하는 것
<br><a href=".?query=tag:STP" class="tag" target="_blank" rel="noopener">#STP</a> ✅ Loop를 방지<br>
Spanning Tree Protocol<br>
특정 Port를 차단 상태로 바꾸어 놓음<br><a href=".?query=tag:Domain" class="tag" target="_blank" rel="noopener">#Domain</a> <br>
<br>컴퓨터에 부여된 계층적인 이름 (사람이 외우기 쉬운 의미가 있는 이름)
<br><a href=".?query=tag:DNS" class="tag" target="_blank" rel="noopener">#DNS</a> : 도메인명과 IP 주소를 상호 변환하는 구조 (Domain Name System)

<br>구성 : content server, cache server, 컴퓨터 내부의 stub resolver
<br>가치가 제대로 발휘될 때 : GSLB (Global Server Load Balancing)


<br><a href=".?query=tag:public_subnet" class="tag" target="_blank" rel="noopener">#public_subnet</a> ✅ 외부에서 직접 접근 가능한 서브넷<br>
<br>public subnet에 속한 리소스는 외부에서 직접 접근이 가능함. 
<br>리소스 - 웹 서버, 로드 밸런서, CDN 등<br>
<a href=".?query=tag:CDN" class="tag" target="_blank" rel="noopener">#CDN</a> (Content Delivery Network) - end user에게 더 빠르게 contents 제공 가능, 로드 시간이 빨라진다.
<br>public ip를 통해 직접 인터넷과 통신 가능
<br>Internet g/w를 포함하여 외부와의 통신을 허용하는 라우팅 규칙을 지님
<br><a href=".?query=tag:private_subnet" class="tag" target="_blank" rel="noopener">#private_subnet</a> ✅ 외부에서 직접 접근 불가한 서브넷<br>
<br>private_subnet에 속한 리소스는 외부에서 직접 접근이 불가능함.
<br>리소스 - DB 서버, Application 서버
<br>외부와 통신하기 위해서는 NAT(Network Address Translation) g/w를 사용하여야 함.
<br><a href=".?query=tag:connection_pool" class="tag" target="_blank" rel="noopener">#connection_pool</a> ✅ 미리 준비된 연결 객체<br>
<br>여러 client에서 동시에 db에 접근할 수 있도록 하는 메커니즘. 
<br>원리 - 각 client는 필요할 때 db 연결을 pool에서 가져와 사용하고, 사용이 끝나면 pool에 반환함.
<br>장점<br>
db 연결을 맺고 해제하는 과정 -&gt; 고 비용. connection pool을 통해 이미 생성된 연결을 재사용함으로써 연결을 맺고 해제하는 데 필요한 overhead를 줄일 수 있음.<br>
여러 client 요청에 대해 동시에 여러 연결을 효과적으로 처리할 수 있음.(scaling)<br>
<a data-tooltip-position="top" aria-label="https://shuu.tistory.com/130" rel="noopener" class="external-link" href="https://shuu.tistory.com/130" target="_blank">connection pool이란?</a>
<br><a href=".?query=tag:NAT" class="tag" target="_blank" rel="noopener">#NAT</a>  ✅ 네트워크 주소 변환 (사설 IP → 공인 IP)<br>
Network Address Translation<br>
<br>private ip를 사용하는 device들을 공인 IP 주소 하나로 변환하여 인터넷과 통신할 있게 하는 기술
<br>IP 주소 부족 문제를 해결 + 방화벽 역할
<br>대칭키 방식 암호화 <br>
<br>암호화하고 복호화하는 key가 똑같다.<br>
<br><a href=".?query=tag:공개키_암호화" class="tag" target="_blank" rel="noopener">#공개키_암호화</a><br>
비대칭키 방식 암호화 (=공개키 암호화) <br>
<br>공개키는 어디든 뿌려져도 된다. 복호화 시에는 개인키를 사용해서 풀기 때문. 다만 이 개인키 (private key)는 알려지면 절대 안된다.<br>
<br>결론<br>
대칭키 + 비대칭키 혼합 방식을 사용해서 HTTPS (HTTP+Secure) 통신을 한다.<br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=H6lpFRpyl14" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=H6lpFRpyl14" target="_blank">대칭키 vs 비대칭키</a>
<br><a href=".?query=tag:RTO" class="tag" target="_blank" rel="noopener">#RTO</a> / <a href=".?query=tag:RPO" class="tag" target="_blank" rel="noopener">#RPO</a><br>
<br>RTO (Recovery Time Objective, 목표 복구 시간)<br>
비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미<br>
ex) 장애 발생 후 4시간 내 복구 가능 <br>
<br>RPO (Recovery Point Objective, 목표 복구 시점)<br>
비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미<br>
ex) 장애 발생 전인 지난 주 목요일에 백업시켜 둔 복원 시점으로 복구 가능
<br><a href=".?query=tag:SLA" class="tag" target="_blank" rel="noopener">#SLA</a> / <a href=".?query=tag:SLI" class="tag" target="_blank" rel="noopener">#SLI</a> / <a href=".?query=tag:SLA" class="tag" target="_blank" rel="noopener">#SLA</a> ✅ 서비스 레벨과 관련된 용어<br>
<a data-tooltip-position="top" aria-label="https://newrelic.com/kr/blog/best-practices/what-are-slos-slis-slas" rel="noopener" class="external-link" href="https://newrelic.com/kr/blog/best-practices/what-are-slos-slis-slas" target="_blank">SLO, SLI, SLA란?</a><br>
<br>SLO (Service Level Objectives, 서비스 레벨 목표) : 시스템에서 기대되는 가용성을 설정한 목표
<br>SLI (Service Level Indicator, 서비스 레벨 지표) : 시스템의 가용성을 파악하기 위한 핵심 측정치와 지표
<br>SLA (Service Level Agreements, 서비스 레벨 계약) : 시스템이 SLO를 충족하지 못할 경우 발생하는 상황, 합의된 내용을 설명하는 계약
<br><a href=".?query=tag:SRE" class="tag" target="_blank" rel="noopener">#SRE</a><br>
<br>Site Reliability Engineering, SRE : 사이트 안정성 엔지니어링
<br><a href=".?query=tag:BlackboxTest" class="tag" target="_blank" rel="noopener">#BlackboxTest</a> 🔑 내부 구조를 모른다.<br>
<br>소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 방법
<br>A, B, C 요구사항 명세를 보면서 테스트하는 것으로, 주로 구현된 기능을 테스트한다. = (기능 테스트)
<br><a href=".?query=tag:3-tier-architecture" class="tag" target="_blank" rel="noopener">#3-tier-architecture</a> 🔑 Presentation.Application.Data<br>
<img alt="Client-Server-DB" src="https://www.zirous.com/wp-content/uploads/2022/10/Untitled-5-01.png" referrerpolicy="no-referrer" style="width: 400px; max-width: 100%;"><br>
<br>Presentation tier : 사용자가 직접 마주하게 되는 계층. GUI / Front-end
<br>Application tier : 정보를 처리하고 가공하며 비즈니스 로직을 처리하는 계층.<br>
ex) 미들웨어 / Back-end. WAS (웹 애플리케이션 서버)
<br>Data tier = DB에 접근해서 데이터를 read/write 하는 것. DBMS
<br><a href=".?query=tag:webRTC" class="tag" target="_blank" rel="noopener">#webRTC</a> 🔑 브라우저에서 P2P 통신을 가능하게 해주는 기술 <a data-href="Network" href="network.html" class="internal-link" target="_self" rel="noopener">Network</a><br>
<br>Web_&nbsp;Real-Time Communication
<br>실시간으로 웹에서 데이터를 교환할 수 있는 기술.
<br>UDP 위에서 동작한다. 데이터의 빠른 전송은 가능하지만, 데이터 손실이 발생할 수도 있다.
<br><a data-tooltip-position="top" aria-label="https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html" rel="noopener" class="external-link" href="https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html" target="_blank">Ref</a>
<br>사설 IP 대역대<br>
<br>10.0.0.0 ~ 10.255.255.255
<br>172.16.0.0 ~ 172.31.255.255
<br>192.168.0.0 ~ 192.168.255.255
<br><a href=".?query=tag:proxy" class="tag" target="_blank" rel="noopener">#proxy</a> 🔑 중계 역할을 해주는 프로그램 / 컴퓨터<br>
<br>Proxy Server<img alt="500" src="https://www.fortinet.com/content/fortinet-com/ko_kr/resources/cyberglossary/proxy-server/_jcr_content/par/c05_container_copy_c/par/c28_image_copy_copy_.img.jpg/1701208391335.jpg" referrerpolicy="no-referrer">
<br>종류

<br>forword proxy : 인터넷 상에서 어디로든지 요청을 전송해주는 프록시<br>
<img src="https://hudi.blog/static/75cb835d72f618f739d8ef3494bdf579/ca1dc/forward-proxy.png" referrerpolicy="no-referrer">
<br>reverse proxy : 인터넷에서 요청을 받으면, 내부망 내의 서버로 전송 해주는 프록시<br>
<img src="https://hudi.blog/static/31b3c81452e707e49e4567090c4431b2/ca1dc/reverse-proxy.png" referrerpolicy="no-referrer">


]]></description><link>it-terms.html</link><guid isPermaLink="false">IT Terms.md</guid><pubDate>Wed, 13 Mar 2024 00:51:09 GMT</pubDate><enclosure url="https://www.cloudflare.com/img/learning/security/glossary/what-is-ssl/http-vs-https.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.cloudflare.com/img/learning/security/glossary/what-is-ssl/http-vs-https.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[오픈소스 메시징 시스템]]></title><description><![CDATA[<a class="tag" href="?query=tag:Kafka" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Kafka</a> 
 <br><a href=".?query=tag:Kafka" class="tag" target="_blank" rel="noopener">#Kafka</a><br><br>Message Queue - 분산화된 환경에서 발신자와 수신자 사이에서 메시지를 전송, 수신하는 기술.<br>
MOM (Message Oriented Middleware)을 통해서 구현된다.<br>왜 사용하나?<br>
<br>느슨한 결합 (발신자와 수신자가 서로 의존 X)
<br>보장성 (발신자가 발생한 모든 메시지는 수신자에게 전달된다.)
<br>구분<br>
<br>Point to Point (P2P) : 한 대의 발신자가 한 대의 수신자에게 메시지를 보낸다. 
<br>Pub/Sub : 발신자가 메시지를 전송한다. (토픽) 해당 공간을 구독하는 수신자 모두 메시지를 수신한다. 
<br>RabbitMQ &amp; ActiveMQ는 모두 지원하나, kafka는 pub/sub 모델만을 지원한다.<br>모든 흐름이 카프카로 모인다.<br><a data-tooltip-position="top" aria-label="https://hudi.blog/what-is-kafka/" rel="noopener" class="external-link" href="https://hudi.blog/what-is-kafka/" target="_blank">what-is-kafka</a><br>
<a rel="noopener" class="external-link" href="https://fastcampus.co.kr/story_article_newkafka" target="_blank">https://fastcampus.co.kr/story_article_newkafka</a>]]></description><link>kafka.html</link><guid isPermaLink="false">Kafka.md</guid><pubDate>Tue, 12 Mar 2024 08:49:43 GMT</pubDate></item><item><title><![CDATA[Linux]]></title><description/></item></channel></rss>