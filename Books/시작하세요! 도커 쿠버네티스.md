#docker #kubernetes [[Kubernetes]]
![100](https://image.yes24.com/goods/84927385/XL)
#### 1장) 도커란?

#### 2장) 도커 엔진

- **도커 볼륨 (-v)** 
컨테이너의 데이터를 영속적 데이터로 활용할 수 있는 방법 중 하나.
&rarr; 1. 호스트와 볼륨을 공유 2. 볼륨 컨테이너 활용 3. 도커가 관리하는 볼륨 생성
- --mount 와 같은 역할을 한다.
- 컨테이너가 아닌 외부에 데이터를 저장, 컨테이너는 그 데이터로 동작하도록 설계 &rarr; **stateless**
- 즉, 컨테이너가 삭제되어도 데이터는 보존된다. 바람직한 설계 방법
<br/>
- **도커의 구조**
&rarr; 1. Docker as a client 
&rarr; 2. Docker as a server : 실제로 컨테이너를 생성, 실행, 이미지를 관리하는 주체. <br/> dockerd 프로세스로서 동작한다.
<br/>
- **도커 데몬 (demon)**
도커 프로세스가 실행되어 서버로부터 입력 받을 준비가 된 상태.
<br/>
- **컨테이너를 외부에 노출**
컨테이너도 가상 IP 주소를 할당받고, 도커의 경우 172.17.0.X 의 IP를 컨테이너에 할당한다. 그리고 이를 할당받은 eth0 인터페이스와 lo (로컬호스트) 인터페이스가 있다. <br/> 외부에 이 앱을 노출하려면 eth0의 IP와 포트를 host의 IP와 포트에 바인딩해야 한다. [[포트포워딩.excalidraw]]
*호스트의 포트* : *컨테이너의 포트*

#### 3장) 도커 스웜

가정) 
하나의 호스트 머신에서 구동하는 도커 엔진... CPU / Memory / Disk 용량 같은 **자원이 부족해지면**? &rarr; 여러 대의 서버를 클러스터로 만들어 자원을 병렬로 확장하는 방법이 있다. <br/> 그러나 +a가 되었을 때 스케줄러, LB 문제, 클러스터 내 서버 다운 시 HA를 어떻게 보장할 지 이슈가 존재. 그 대안이 바로 #Docker_Swarm 

- 도커 스웜(docker swarm)을 사용하는 이유 - **여러 대의 docker 서버**를 하나의 클러스터로 만들어 컨테이너를 생성하는 기능을 제공한다.
- 스웜 클래식 
- 도커 스웜 모드 MSA의 컨테이너를 다루기 위한 클러스터링 기능에 초점

#### 4장) 도커 컴포즈

- 매번 run 명령어에 옵션을 설정해 CLI로 컨테이너를 생성하기보다는 **여러 개의 컨테이너를 하나의 서비스로 정의해 묶음으로 관리**하는 Docker Compose가 더 효율적이다.
- 각 컨테이너의 의존성, 네트워크, 볼륨 등을 정의 가능하다.
- 사용법 : run 명령어 &rarr; YAML
- 구성 : version, service, volume, network 정의

#### 5장) 쿠버네티스 설치

- 조타수를 의미하며 CNCF에 소속된 오픈소스이다.
- 컨테이너 기반의 서비스 운영에 필요한 오케스트레이션 기능을 지원한다.
- *여러 서버의 자원을 클러스터링해 컨테이너를 배치*하는 것이 K8s의 핵심 기능.
- 어떤 사용 환경? 
	1. 클라우드 플랫폼 환경 ([EKS](https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/what-is-eks.html), GKE, [AKS](https://azure.microsoft.com/ko-kr/products/kubernetes-service), EC2와 같은 클라우드 서버 인프라에 K8s 설치)
	2. 자체 서버 (on-premise)
- calico #Overlay_Network 

#### 6장) 쿠버네티스 시작하기

##### 쿠버네티스 오브젝트(Object)
- **Pods** : ==컨테이너의 집합==
	- 컨테이너 application의 기본 단위.
	- Why not docker container? &rarr; 리눅스 #Namespace 를 공유하는 여러 컨테이너들을 추상화된 집합으로 사용하기 위함.
	- 포드에 정의된 여러 개의 컨테이너는 하나의 완전한 애플리케이션으로 동작함.
	
- **Replica Set** : ==Pods를 관리하는 컨트롤러==
	- 일정 개수의 포드를 유지하는 컨트롤러

- **Deployment** : ==Replica Set, Pod의 배포를 관리==
	- Replica Set의 상위 오브젝트
		- Why Replica Set 있는데 deployment를 쓰나? &rarr; 애플리케이션의 업데이트와 배포를 더욱 편하게 만들기 위해서. (for rollback, rolling update #Deployment )
	
- **Service** : ==Pod를 연결하고 외부에 노출==
	- K8s에서는 Pod에 접근하도록 어떻게 정의하나?
		- docker의 경우, -p 옵션을 사용하면 컨테이너를 외부로 노출할 수 있다. (= container 생성과 동시에 외부로 노출되는 방식)

##### 쿠버네티스 Node
- **Master Node** : 쿠버네티스가 동작할 수 있게 클러스터를 관리
	- API server
	- CM (controller manager)
	- Scheduler
- kubelet : 컨테이너 생성, 삭제, Master-Worker Node 간 통신을 담당하는 agent
- **Worker Node** : application container가 생성된다.

#### 7장) 쿠버네티스 리소스의 관리와 설정
- K8s에서 앱을 배포하기 위한 필수 요소 4 
- #Pod / #ReplicaSet / #Deployment / #Service 
- #Namespace 
- Configmap, Secret - 설정 값을 포드에 전달

### 쿠버네티스 고급 기능 활용
#### 8장) 인그레스(Ingress)

- 외부 &rarr; 내부로 향하는 것을 지칭한다.
- 라우팅 정의나 보안 연결과 같은 세부 설정 (*외부 요청에 대한 처리 규칙*)이 수행된다.

#### 9장) 퍼시스턴트 볼륨(PV)와 퍼시스턴트 볼륨 클레임(PVC)

- DB 처럼 포드 내부에서 특정 데이터를 보유해야 하는 경우
- deployment 삭제 &rarr; pod + pod의 data 삭제 &rarr; ==포드의 데이터를 영속적으로 저장하기 위한 방법인 **PV** 필요==
- PV (Persistent Volume) - 워커 노드들이 네트워크 상에서 storage를 mount해 영속적으로 데이터를 저장할 수 있는 볼륨
- PVC - 사용자가 PV에 하는 요청

#### 10장) 보안을 위한 인증과 인가 : Service Account와 RBAC

#### 11장) 애플리케이션 배포를 위한 고급 설정

#### 12장) 커스텀 리소스와 컨트롤러

#### 13장) 포드를 사용하는 다른 오브젝트들

#### 14장) 쿠버네티스 모니터링
